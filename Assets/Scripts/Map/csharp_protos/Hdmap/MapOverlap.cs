// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/map/proto/map_overlap.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Apollo.Hdmap {

  /// <summary>Holder for reflection information generated from modules/map/proto/map_overlap.proto</summary>
  public static partial class MapOverlapReflection {

    #region Descriptor
    /// <summary>File descriptor for modules/map/proto/map_overlap.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MapOverlapReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiNtb2R1bGVzL21hcC9wcm90by9tYXBfb3ZlcmxhcC5wcm90bxIMYXBvbGxv",
            "LmhkbWFwGh5tb2R1bGVzL21hcC9wcm90by9tYXBfaWQucHJvdG8iQwoPTGFu",
            "ZU92ZXJsYXBJbmZvEg8KB3N0YXJ0X3MYASABKAESDQoFZW5kX3MYAiABKAES",
            "EAoIaXNfbWVyZ2UYAyABKAgiEwoRU2lnbmFsT3ZlcmxhcEluZm8iFQoTU3Rv",
            "cFNpZ25PdmVybGFwSW5mbyIWChRDcm9zc3dhbGtPdmVybGFwSW5mbyIVChNK",
            "dW5jdGlvbk92ZXJsYXBJbmZvIhIKEFlpZWxkT3ZlcmxhcEluZm8iFgoUQ2xl",
            "YXJBcmVhT3ZlcmxhcEluZm8iFgoUU3BlZWRCdW1wT3ZlcmxhcEluZm8iGQoX",
            "UGFya2luZ1NwYWNlT3ZlcmxhcEluZm8iqgUKEU9iamVjdE92ZXJsYXBJbmZv",
            "EhwKAmlkGAEgASgLMhAuYXBvbGxvLmhkbWFwLklkEjoKEWxhbmVfb3Zlcmxh",
            "cF9pbmZvGAMgASgLMh0uYXBvbGxvLmhkbWFwLkxhbmVPdmVybGFwSW5mb0gA",
            "Ej4KE3NpZ25hbF9vdmVybGFwX2luZm8YBCABKAsyHy5hcG9sbG8uaGRtYXAu",
            "U2lnbmFsT3ZlcmxhcEluZm9IABJDChZzdG9wX3NpZ25fb3ZlcmxhcF9pbmZv",
            "GAUgASgLMiEuYXBvbGxvLmhkbWFwLlN0b3BTaWduT3ZlcmxhcEluZm9IABJE",
            "ChZjcm9zc3dhbGtfb3ZlcmxhcF9pbmZvGAYgASgLMiIuYXBvbGxvLmhkbWFw",
            "LkNyb3Nzd2Fsa092ZXJsYXBJbmZvSAASQgoVanVuY3Rpb25fb3ZlcmxhcF9p",
            "bmZvGAcgASgLMiEuYXBvbGxvLmhkbWFwLkp1bmN0aW9uT3ZlcmxhcEluZm9I",
            "ABJBChd5aWVsZF9zaWduX292ZXJsYXBfaW5mbxgIIAEoCzIeLmFwb2xsby5o",
            "ZG1hcC5ZaWVsZE92ZXJsYXBJbmZvSAASRQoXY2xlYXJfYXJlYV9vdmVybGFw",
            "X2luZm8YCSABKAsyIi5hcG9sbG8uaGRtYXAuQ2xlYXJBcmVhT3ZlcmxhcElu",
            "Zm9IABJFChdzcGVlZF9idW1wX292ZXJsYXBfaW5mbxgKIAEoCzIiLmFwb2xs",
            "by5oZG1hcC5TcGVlZEJ1bXBPdmVybGFwSW5mb0gAEksKGnBhcmtpbmdfc3Bh",
            "Y2Vfb3ZlcmxhcF9pbmZvGAsgASgLMiUuYXBvbGxvLmhkbWFwLlBhcmtpbmdT",
            "cGFjZU92ZXJsYXBJbmZvSABCDgoMb3ZlcmxhcF9pbmZvIlgKB092ZXJsYXAS",
            "HAoCaWQYASABKAsyEC5hcG9sbG8uaGRtYXAuSWQSLwoGb2JqZWN0GAIgAygL",
            "Mh8uYXBvbGxvLmhkbWFwLk9iamVjdE92ZXJsYXBJbmZvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Apollo.Hdmap.MapIdReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.LaneOverlapInfo), global::Apollo.Hdmap.LaneOverlapInfo.Parser, new[]{ "StartS", "EndS", "IsMerge" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.SignalOverlapInfo), global::Apollo.Hdmap.SignalOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.StopSignOverlapInfo), global::Apollo.Hdmap.StopSignOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.CrosswalkOverlapInfo), global::Apollo.Hdmap.CrosswalkOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.JunctionOverlapInfo), global::Apollo.Hdmap.JunctionOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.YieldOverlapInfo), global::Apollo.Hdmap.YieldOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.ClearAreaOverlapInfo), global::Apollo.Hdmap.ClearAreaOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.SpeedBumpOverlapInfo), global::Apollo.Hdmap.SpeedBumpOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.ParkingSpaceOverlapInfo), global::Apollo.Hdmap.ParkingSpaceOverlapInfo.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.ObjectOverlapInfo), global::Apollo.Hdmap.ObjectOverlapInfo.Parser, new[]{ "Id", "LaneOverlapInfo", "SignalOverlapInfo", "StopSignOverlapInfo", "CrosswalkOverlapInfo", "JunctionOverlapInfo", "YieldSignOverlapInfo", "ClearAreaOverlapInfo", "SpeedBumpOverlapInfo", "ParkingSpaceOverlapInfo" }, new[]{ "OverlapInfo" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.Overlap), global::Apollo.Hdmap.Overlap.Parser, new[]{ "Id", "Object" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class LaneOverlapInfo : pb::IMessage<LaneOverlapInfo> {
    private static readonly pb::MessageParser<LaneOverlapInfo> _parser = new pb::MessageParser<LaneOverlapInfo>(() => new LaneOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LaneOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneOverlapInfo(LaneOverlapInfo other) : this() {
      startS_ = other.startS_;
      endS_ = other.endS_;
      isMerge_ = other.isMerge_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneOverlapInfo Clone() {
      return new LaneOverlapInfo(this);
    }

    /// <summary>Field number for the "start_s" field.</summary>
    public const int StartSFieldNumber = 1;
    private double startS_;
    /// <summary>
    ///position (s-coordinate)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StartS {
      get { return startS_; }
      set {
        startS_ = value;
      }
    }

    /// <summary>Field number for the "end_s" field.</summary>
    public const int EndSFieldNumber = 2;
    private double endS_;
    /// <summary>
    ///position (s-coordinate)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double EndS {
      get { return endS_; }
      set {
        endS_ = value;
      }
    }

    /// <summary>Field number for the "is_merge" field.</summary>
    public const int IsMergeFieldNumber = 3;
    private bool isMerge_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMerge {
      get { return isMerge_; }
      set {
        isMerge_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LaneOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LaneOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartS != other.StartS) return false;
      if (EndS != other.EndS) return false;
      if (IsMerge != other.IsMerge) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StartS != 0D) hash ^= StartS.GetHashCode();
      if (EndS != 0D) hash ^= EndS.GetHashCode();
      if (IsMerge != false) hash ^= IsMerge.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StartS != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(StartS);
      }
      if (EndS != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(EndS);
      }
      if (IsMerge != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsMerge);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StartS != 0D) {
        size += 1 + 8;
      }
      if (EndS != 0D) {
        size += 1 + 8;
      }
      if (IsMerge != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LaneOverlapInfo other) {
      if (other == null) {
        return;
      }
      if (other.StartS != 0D) {
        StartS = other.StartS;
      }
      if (other.EndS != 0D) {
        EndS = other.EndS;
      }
      if (other.IsMerge != false) {
        IsMerge = other.IsMerge;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            StartS = input.ReadDouble();
            break;
          }
          case 17: {
            EndS = input.ReadDouble();
            break;
          }
          case 24: {
            IsMerge = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SignalOverlapInfo : pb::IMessage<SignalOverlapInfo> {
    private static readonly pb::MessageParser<SignalOverlapInfo> _parser = new pb::MessageParser<SignalOverlapInfo>(() => new SignalOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignalOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignalOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignalOverlapInfo(SignalOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignalOverlapInfo Clone() {
      return new SignalOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignalOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignalOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignalOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class StopSignOverlapInfo : pb::IMessage<StopSignOverlapInfo> {
    private static readonly pb::MessageParser<StopSignOverlapInfo> _parser = new pb::MessageParser<StopSignOverlapInfo>(() => new StopSignOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StopSignOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopSignOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopSignOverlapInfo(StopSignOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopSignOverlapInfo Clone() {
      return new StopSignOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StopSignOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StopSignOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StopSignOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class CrosswalkOverlapInfo : pb::IMessage<CrosswalkOverlapInfo> {
    private static readonly pb::MessageParser<CrosswalkOverlapInfo> _parser = new pb::MessageParser<CrosswalkOverlapInfo>(() => new CrosswalkOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CrosswalkOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrosswalkOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrosswalkOverlapInfo(CrosswalkOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrosswalkOverlapInfo Clone() {
      return new CrosswalkOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CrosswalkOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CrosswalkOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CrosswalkOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class JunctionOverlapInfo : pb::IMessage<JunctionOverlapInfo> {
    private static readonly pb::MessageParser<JunctionOverlapInfo> _parser = new pb::MessageParser<JunctionOverlapInfo>(() => new JunctionOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<JunctionOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JunctionOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JunctionOverlapInfo(JunctionOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JunctionOverlapInfo Clone() {
      return new JunctionOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as JunctionOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(JunctionOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(JunctionOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class YieldOverlapInfo : pb::IMessage<YieldOverlapInfo> {
    private static readonly pb::MessageParser<YieldOverlapInfo> _parser = new pb::MessageParser<YieldOverlapInfo>(() => new YieldOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<YieldOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public YieldOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public YieldOverlapInfo(YieldOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public YieldOverlapInfo Clone() {
      return new YieldOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as YieldOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(YieldOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(YieldOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class ClearAreaOverlapInfo : pb::IMessage<ClearAreaOverlapInfo> {
    private static readonly pb::MessageParser<ClearAreaOverlapInfo> _parser = new pb::MessageParser<ClearAreaOverlapInfo>(() => new ClearAreaOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ClearAreaOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClearAreaOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClearAreaOverlapInfo(ClearAreaOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClearAreaOverlapInfo Clone() {
      return new ClearAreaOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ClearAreaOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ClearAreaOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ClearAreaOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class SpeedBumpOverlapInfo : pb::IMessage<SpeedBumpOverlapInfo> {
    private static readonly pb::MessageParser<SpeedBumpOverlapInfo> _parser = new pb::MessageParser<SpeedBumpOverlapInfo>(() => new SpeedBumpOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SpeedBumpOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SpeedBumpOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SpeedBumpOverlapInfo(SpeedBumpOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SpeedBumpOverlapInfo Clone() {
      return new SpeedBumpOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SpeedBumpOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SpeedBumpOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SpeedBumpOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class ParkingSpaceOverlapInfo : pb::IMessage<ParkingSpaceOverlapInfo> {
    private static readonly pb::MessageParser<ParkingSpaceOverlapInfo> _parser = new pb::MessageParser<ParkingSpaceOverlapInfo>(() => new ParkingSpaceOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ParkingSpaceOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParkingSpaceOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParkingSpaceOverlapInfo(ParkingSpaceOverlapInfo other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParkingSpaceOverlapInfo Clone() {
      return new ParkingSpaceOverlapInfo(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ParkingSpaceOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ParkingSpaceOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ParkingSpaceOverlapInfo other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  /// Information about one object in the overlap.
  /// </summary>
  public sealed partial class ObjectOverlapInfo : pb::IMessage<ObjectOverlapInfo> {
    private static readonly pb::MessageParser<ObjectOverlapInfo> _parser = new pb::MessageParser<ObjectOverlapInfo>(() => new ObjectOverlapInfo());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ObjectOverlapInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectOverlapInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectOverlapInfo(ObjectOverlapInfo other) : this() {
      Id = other.id_ != null ? other.Id.Clone() : null;
      switch (other.OverlapInfoCase) {
        case OverlapInfoOneofCase.LaneOverlapInfo:
          LaneOverlapInfo = other.LaneOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.SignalOverlapInfo:
          SignalOverlapInfo = other.SignalOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.StopSignOverlapInfo:
          StopSignOverlapInfo = other.StopSignOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.CrosswalkOverlapInfo:
          CrosswalkOverlapInfo = other.CrosswalkOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.JunctionOverlapInfo:
          JunctionOverlapInfo = other.JunctionOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.YieldSignOverlapInfo:
          YieldSignOverlapInfo = other.YieldSignOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.ClearAreaOverlapInfo:
          ClearAreaOverlapInfo = other.ClearAreaOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.SpeedBumpOverlapInfo:
          SpeedBumpOverlapInfo = other.SpeedBumpOverlapInfo.Clone();
          break;
        case OverlapInfoOneofCase.ParkingSpaceOverlapInfo:
          ParkingSpaceOverlapInfo = other.ParkingSpaceOverlapInfo.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectOverlapInfo Clone() {
      return new ObjectOverlapInfo(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Apollo.Hdmap.Id id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Id Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "lane_overlap_info" field.</summary>
    public const int LaneOverlapInfoFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.LaneOverlapInfo LaneOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.LaneOverlapInfo ? (global::Apollo.Hdmap.LaneOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.LaneOverlapInfo;
      }
    }

    /// <summary>Field number for the "signal_overlap_info" field.</summary>
    public const int SignalOverlapInfoFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.SignalOverlapInfo SignalOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.SignalOverlapInfo ? (global::Apollo.Hdmap.SignalOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.SignalOverlapInfo;
      }
    }

    /// <summary>Field number for the "stop_sign_overlap_info" field.</summary>
    public const int StopSignOverlapInfoFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.StopSignOverlapInfo StopSignOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.StopSignOverlapInfo ? (global::Apollo.Hdmap.StopSignOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.StopSignOverlapInfo;
      }
    }

    /// <summary>Field number for the "crosswalk_overlap_info" field.</summary>
    public const int CrosswalkOverlapInfoFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.CrosswalkOverlapInfo CrosswalkOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.CrosswalkOverlapInfo ? (global::Apollo.Hdmap.CrosswalkOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.CrosswalkOverlapInfo;
      }
    }

    /// <summary>Field number for the "junction_overlap_info" field.</summary>
    public const int JunctionOverlapInfoFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.JunctionOverlapInfo JunctionOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.JunctionOverlapInfo ? (global::Apollo.Hdmap.JunctionOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.JunctionOverlapInfo;
      }
    }

    /// <summary>Field number for the "yield_sign_overlap_info" field.</summary>
    public const int YieldSignOverlapInfoFieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.YieldOverlapInfo YieldSignOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.YieldSignOverlapInfo ? (global::Apollo.Hdmap.YieldOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.YieldSignOverlapInfo;
      }
    }

    /// <summary>Field number for the "clear_area_overlap_info" field.</summary>
    public const int ClearAreaOverlapInfoFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.ClearAreaOverlapInfo ClearAreaOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.ClearAreaOverlapInfo ? (global::Apollo.Hdmap.ClearAreaOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.ClearAreaOverlapInfo;
      }
    }

    /// <summary>Field number for the "speed_bump_overlap_info" field.</summary>
    public const int SpeedBumpOverlapInfoFieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.SpeedBumpOverlapInfo SpeedBumpOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.SpeedBumpOverlapInfo ? (global::Apollo.Hdmap.SpeedBumpOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.SpeedBumpOverlapInfo;
      }
    }

    /// <summary>Field number for the "parking_space_overlap_info" field.</summary>
    public const int ParkingSpaceOverlapInfoFieldNumber = 11;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.ParkingSpaceOverlapInfo ParkingSpaceOverlapInfo {
      get { return overlapInfoCase_ == OverlapInfoOneofCase.ParkingSpaceOverlapInfo ? (global::Apollo.Hdmap.ParkingSpaceOverlapInfo) overlapInfo_ : null; }
      set {
        overlapInfo_ = value;
        overlapInfoCase_ = value == null ? OverlapInfoOneofCase.None : OverlapInfoOneofCase.ParkingSpaceOverlapInfo;
      }
    }

    private object overlapInfo_;
    /// <summary>Enum of possible cases for the "overlap_info" oneof.</summary>
    public enum OverlapInfoOneofCase {
      None = 0,
      LaneOverlapInfo = 3,
      SignalOverlapInfo = 4,
      StopSignOverlapInfo = 5,
      CrosswalkOverlapInfo = 6,
      JunctionOverlapInfo = 7,
      YieldSignOverlapInfo = 8,
      ClearAreaOverlapInfo = 9,
      SpeedBumpOverlapInfo = 10,
      ParkingSpaceOverlapInfo = 11,
    }
    private OverlapInfoOneofCase overlapInfoCase_ = OverlapInfoOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OverlapInfoOneofCase OverlapInfoCase {
      get { return overlapInfoCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOverlapInfo() {
      overlapInfoCase_ = OverlapInfoOneofCase.None;
      overlapInfo_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ObjectOverlapInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ObjectOverlapInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(LaneOverlapInfo, other.LaneOverlapInfo)) return false;
      if (!object.Equals(SignalOverlapInfo, other.SignalOverlapInfo)) return false;
      if (!object.Equals(StopSignOverlapInfo, other.StopSignOverlapInfo)) return false;
      if (!object.Equals(CrosswalkOverlapInfo, other.CrosswalkOverlapInfo)) return false;
      if (!object.Equals(JunctionOverlapInfo, other.JunctionOverlapInfo)) return false;
      if (!object.Equals(YieldSignOverlapInfo, other.YieldSignOverlapInfo)) return false;
      if (!object.Equals(ClearAreaOverlapInfo, other.ClearAreaOverlapInfo)) return false;
      if (!object.Equals(SpeedBumpOverlapInfo, other.SpeedBumpOverlapInfo)) return false;
      if (!object.Equals(ParkingSpaceOverlapInfo, other.ParkingSpaceOverlapInfo)) return false;
      if (OverlapInfoCase != other.OverlapInfoCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.LaneOverlapInfo) hash ^= LaneOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.SignalOverlapInfo) hash ^= SignalOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.StopSignOverlapInfo) hash ^= StopSignOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.CrosswalkOverlapInfo) hash ^= CrosswalkOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.JunctionOverlapInfo) hash ^= JunctionOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.YieldSignOverlapInfo) hash ^= YieldSignOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.ClearAreaOverlapInfo) hash ^= ClearAreaOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.SpeedBumpOverlapInfo) hash ^= SpeedBumpOverlapInfo.GetHashCode();
      if (overlapInfoCase_ == OverlapInfoOneofCase.ParkingSpaceOverlapInfo) hash ^= ParkingSpaceOverlapInfo.GetHashCode();
      hash ^= (int) overlapInfoCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.LaneOverlapInfo) {
        output.WriteRawTag(26);
        output.WriteMessage(LaneOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.SignalOverlapInfo) {
        output.WriteRawTag(34);
        output.WriteMessage(SignalOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.StopSignOverlapInfo) {
        output.WriteRawTag(42);
        output.WriteMessage(StopSignOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.CrosswalkOverlapInfo) {
        output.WriteRawTag(50);
        output.WriteMessage(CrosswalkOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.JunctionOverlapInfo) {
        output.WriteRawTag(58);
        output.WriteMessage(JunctionOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.YieldSignOverlapInfo) {
        output.WriteRawTag(66);
        output.WriteMessage(YieldSignOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.ClearAreaOverlapInfo) {
        output.WriteRawTag(74);
        output.WriteMessage(ClearAreaOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.SpeedBumpOverlapInfo) {
        output.WriteRawTag(82);
        output.WriteMessage(SpeedBumpOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.ParkingSpaceOverlapInfo) {
        output.WriteRawTag(90);
        output.WriteMessage(ParkingSpaceOverlapInfo);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.LaneOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LaneOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.SignalOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SignalOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.StopSignOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StopSignOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.CrosswalkOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CrosswalkOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.JunctionOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(JunctionOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.YieldSignOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(YieldSignOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.ClearAreaOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClearAreaOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.SpeedBumpOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SpeedBumpOverlapInfo);
      }
      if (overlapInfoCase_ == OverlapInfoOneofCase.ParkingSpaceOverlapInfo) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ParkingSpaceOverlapInfo);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ObjectOverlapInfo other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          id_ = new global::Apollo.Hdmap.Id();
        }
        Id.MergeFrom(other.Id);
      }
      switch (other.OverlapInfoCase) {
        case OverlapInfoOneofCase.LaneOverlapInfo:
          LaneOverlapInfo = other.LaneOverlapInfo;
          break;
        case OverlapInfoOneofCase.SignalOverlapInfo:
          SignalOverlapInfo = other.SignalOverlapInfo;
          break;
        case OverlapInfoOneofCase.StopSignOverlapInfo:
          StopSignOverlapInfo = other.StopSignOverlapInfo;
          break;
        case OverlapInfoOneofCase.CrosswalkOverlapInfo:
          CrosswalkOverlapInfo = other.CrosswalkOverlapInfo;
          break;
        case OverlapInfoOneofCase.JunctionOverlapInfo:
          JunctionOverlapInfo = other.JunctionOverlapInfo;
          break;
        case OverlapInfoOneofCase.YieldSignOverlapInfo:
          YieldSignOverlapInfo = other.YieldSignOverlapInfo;
          break;
        case OverlapInfoOneofCase.ClearAreaOverlapInfo:
          ClearAreaOverlapInfo = other.ClearAreaOverlapInfo;
          break;
        case OverlapInfoOneofCase.SpeedBumpOverlapInfo:
          SpeedBumpOverlapInfo = other.SpeedBumpOverlapInfo;
          break;
        case OverlapInfoOneofCase.ParkingSpaceOverlapInfo:
          ParkingSpaceOverlapInfo = other.ParkingSpaceOverlapInfo;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (id_ == null) {
              id_ = new global::Apollo.Hdmap.Id();
            }
            input.ReadMessage(id_);
            break;
          }
          case 26: {
            global::Apollo.Hdmap.LaneOverlapInfo subBuilder = new global::Apollo.Hdmap.LaneOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.LaneOverlapInfo) {
              subBuilder.MergeFrom(LaneOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            LaneOverlapInfo = subBuilder;
            break;
          }
          case 34: {
            global::Apollo.Hdmap.SignalOverlapInfo subBuilder = new global::Apollo.Hdmap.SignalOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.SignalOverlapInfo) {
              subBuilder.MergeFrom(SignalOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            SignalOverlapInfo = subBuilder;
            break;
          }
          case 42: {
            global::Apollo.Hdmap.StopSignOverlapInfo subBuilder = new global::Apollo.Hdmap.StopSignOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.StopSignOverlapInfo) {
              subBuilder.MergeFrom(StopSignOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            StopSignOverlapInfo = subBuilder;
            break;
          }
          case 50: {
            global::Apollo.Hdmap.CrosswalkOverlapInfo subBuilder = new global::Apollo.Hdmap.CrosswalkOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.CrosswalkOverlapInfo) {
              subBuilder.MergeFrom(CrosswalkOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            CrosswalkOverlapInfo = subBuilder;
            break;
          }
          case 58: {
            global::Apollo.Hdmap.JunctionOverlapInfo subBuilder = new global::Apollo.Hdmap.JunctionOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.JunctionOverlapInfo) {
              subBuilder.MergeFrom(JunctionOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            JunctionOverlapInfo = subBuilder;
            break;
          }
          case 66: {
            global::Apollo.Hdmap.YieldOverlapInfo subBuilder = new global::Apollo.Hdmap.YieldOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.YieldSignOverlapInfo) {
              subBuilder.MergeFrom(YieldSignOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            YieldSignOverlapInfo = subBuilder;
            break;
          }
          case 74: {
            global::Apollo.Hdmap.ClearAreaOverlapInfo subBuilder = new global::Apollo.Hdmap.ClearAreaOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.ClearAreaOverlapInfo) {
              subBuilder.MergeFrom(ClearAreaOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            ClearAreaOverlapInfo = subBuilder;
            break;
          }
          case 82: {
            global::Apollo.Hdmap.SpeedBumpOverlapInfo subBuilder = new global::Apollo.Hdmap.SpeedBumpOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.SpeedBumpOverlapInfo) {
              subBuilder.MergeFrom(SpeedBumpOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            SpeedBumpOverlapInfo = subBuilder;
            break;
          }
          case 90: {
            global::Apollo.Hdmap.ParkingSpaceOverlapInfo subBuilder = new global::Apollo.Hdmap.ParkingSpaceOverlapInfo();
            if (overlapInfoCase_ == OverlapInfoOneofCase.ParkingSpaceOverlapInfo) {
              subBuilder.MergeFrom(ParkingSpaceOverlapInfo);
            }
            input.ReadMessage(subBuilder);
            ParkingSpaceOverlapInfo = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Here, the "overlap" includes any pair of objects on the map
  /// (e.g. lanes, junctions, and crosswalks).
  /// </summary>
  public sealed partial class Overlap : pb::IMessage<Overlap> {
    private static readonly pb::MessageParser<Overlap> _parser = new pb::MessageParser<Overlap>(() => new Overlap());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Overlap> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapOverlapReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Overlap() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Overlap(Overlap other) : this() {
      Id = other.id_ != null ? other.Id.Clone() : null;
      object_ = other.object_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Overlap Clone() {
      return new Overlap(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Apollo.Hdmap.Id id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Id Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "object" field.</summary>
    public const int ObjectFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.ObjectOverlapInfo> _repeated_object_codec
        = pb::FieldCodec.ForMessage(18, global::Apollo.Hdmap.ObjectOverlapInfo.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.ObjectOverlapInfo> object_ = new pbc::RepeatedField<global::Apollo.Hdmap.ObjectOverlapInfo>();
    /// <summary>
    /// Information about one overlap, include all overlapped objects.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.ObjectOverlapInfo> Object {
      get { return object_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Overlap);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Overlap other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if(!object_.Equals(other.object_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      hash ^= object_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      object_.WriteTo(output, _repeated_object_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      size += object_.CalculateSize(_repeated_object_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Overlap other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          id_ = new global::Apollo.Hdmap.Id();
        }
        Id.MergeFrom(other.Id);
      }
      object_.Add(other.object_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (id_ == null) {
              id_ = new global::Apollo.Hdmap.Id();
            }
            input.ReadMessage(id_);
            break;
          }
          case 18: {
            object_.AddEntriesFrom(input, _repeated_object_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
