// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/map/proto/map_lane.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Apollo.Hdmap {

  /// <summary>Holder for reflection information generated from modules/map/proto/map_lane.proto</summary>
  public static partial class MapLaneReflection {

    #region Descriptor
    /// <summary>File descriptor for modules/map/proto/map_lane.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MapLaneReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiBtb2R1bGVzL21hcC9wcm90by9tYXBfbGFuZS5wcm90bxIMYXBvbGxvLmhk",
            "bWFwGh5tb2R1bGVzL21hcC9wcm90by9tYXBfaWQucHJvdG8aJG1vZHVsZXMv",
            "bWFwL3Byb3RvL21hcF9nZW9tZXRyeS5wcm90byLLAQoQTGFuZUJvdW5kYXJ5",
            "VHlwZRIJCgFzGAEgASgBEjIKBXR5cGVzGAIgAygOMiMuYXBvbGxvLmhkbWFw",
            "LkxhbmVCb3VuZGFyeVR5cGUuVHlwZSJ4CgRUeXBlEgsKB1VOS05PV04QABIR",
            "Cg1ET1RURURfWUVMTE9XEAESEAoMRE9UVEVEX1dISVRFEAISEAoMU09MSURf",
            "WUVMTE9XEAMSDwoLU09MSURfV0hJVEUQBBIRCg1ET1VCTEVfWUVMTE9XEAUS",
            "CAoEQ1VSQhAGIooBCgxMYW5lQm91bmRhcnkSIgoFY3VydmUYASABKAsyEy5h",
            "cG9sbG8uaGRtYXAuQ3VydmUSDgoGbGVuZ3RoGAIgASgBEg8KB3ZpcnR1YWwY",
            "AyABKAgSNQoNYm91bmRhcnlfdHlwZRgEIAMoCzIeLmFwb2xsby5oZG1hcC5M",
            "YW5lQm91bmRhcnlUeXBlIjEKFUxhbmVTYW1wbGVBc3NvY2lhdGlvbhIJCgFz",
            "GAEgASgBEg0KBXdpZHRoGAIgASgBIv8JCgRMYW5lEhwKAmlkGAEgASgLMhAu",
            "YXBvbGxvLmhkbWFwLklkEioKDWNlbnRyYWxfY3VydmUYAiABKAsyEy5hcG9s",
            "bG8uaGRtYXAuQ3VydmUSMQoNbGVmdF9ib3VuZGFyeRgDIAEoCzIaLmFwb2xs",
            "by5oZG1hcC5MYW5lQm91bmRhcnkSMgoOcmlnaHRfYm91bmRhcnkYBCABKAsy",
            "Gi5hcG9sbG8uaGRtYXAuTGFuZUJvdW5kYXJ5Eg4KBmxlbmd0aBgFIAEoARIT",
            "CgtzcGVlZF9saW1pdBgGIAEoARIkCgpvdmVybGFwX2lkGAcgAygLMhAuYXBv",
            "bGxvLmhkbWFwLklkEigKDnByZWRlY2Vzc29yX2lkGAggAygLMhAuYXBvbGxv",
            "LmhkbWFwLklkEiYKDHN1Y2Nlc3Nvcl9pZBgJIAMoCzIQLmFwb2xsby5oZG1h",
            "cC5JZBI3Ch1sZWZ0X25laWdoYm9yX2ZvcndhcmRfbGFuZV9pZBgKIAMoCzIQ",
            "LmFwb2xsby5oZG1hcC5JZBI4Ch5yaWdodF9uZWlnaGJvcl9mb3J3YXJkX2xh",
            "bmVfaWQYCyADKAsyEC5hcG9sbG8uaGRtYXAuSWQSKQoEdHlwZRgMIAEoDjIb",
            "LmFwb2xsby5oZG1hcC5MYW5lLkxhbmVUeXBlEikKBHR1cm4YDSABKA4yGy5h",
            "cG9sbG8uaGRtYXAuTGFuZS5MYW5lVHVybhI3Ch1sZWZ0X25laWdoYm9yX3Jl",
            "dmVyc2VfbGFuZV9pZBgOIAMoCzIQLmFwb2xsby5oZG1hcC5JZBI4Ch5yaWdo",
            "dF9uZWlnaGJvcl9yZXZlcnNlX2xhbmVfaWQYDyADKAsyEC5hcG9sbG8uaGRt",
            "YXAuSWQSJQoLanVuY3Rpb25faWQYECABKAsyEC5hcG9sbG8uaGRtYXAuSWQS",
            "OAoLbGVmdF9zYW1wbGUYESADKAsyIy5hcG9sbG8uaGRtYXAuTGFuZVNhbXBs",
            "ZUFzc29jaWF0aW9uEjkKDHJpZ2h0X3NhbXBsZRgSIAMoCzIjLmFwb2xsby5o",
            "ZG1hcC5MYW5lU2FtcGxlQXNzb2NpYXRpb24SMwoJZGlyZWN0aW9uGBMgASgO",
            "MiAuYXBvbGxvLmhkbWFwLkxhbmUuTGFuZURpcmVjdGlvbhI9ChBsZWZ0X3Jv",
            "YWRfc2FtcGxlGBQgAygLMiMuYXBvbGxvLmhkbWFwLkxhbmVTYW1wbGVBc3Nv",
            "Y2lhdGlvbhI+ChFyaWdodF9yb2FkX3NhbXBsZRgVIAMoCzIjLmFwb2xsby5o",
            "ZG1hcC5MYW5lU2FtcGxlQXNzb2NpYXRpb24ibwoITGFuZVR5cGUSEgoOTEFO",
            "RVRZUEVfRFVNTVkQABIICgROT05FEAESEAoMQ0lUWV9EUklWSU5HEAISCgoG",
            "QklLSU5HEAMSDAoIU0lERVdBTEsQBBILCgdQQVJLSU5HEAUSDAoIU0hPVUxE",
            "RVIQBiJWCghMYW5lVHVybhISCg5MQU5FVFVSTl9EVU1NWRAAEgsKB05PX1RV",
            "Uk4QARINCglMRUZUX1RVUk4QAhIOCgpSSUdIVF9UVVJOEAMSCgoGVV9UVVJO",
            "EAQiVAoNTGFuZURpcmVjdGlvbhIXChNMQU5FRElSRUNUSU9OX0RVTU1ZEAAS",
            "CwoHRk9SV0FSRBABEgwKCEJBQ0tXQVJEEAISDwoLQklESVJFQ1RJT04QA2IG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Apollo.Hdmap.MapIdReflection.Descriptor, global::Apollo.Hdmap.MapGeometryReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.LaneBoundaryType), global::Apollo.Hdmap.LaneBoundaryType.Parser, new[]{ "S", "Types_" }, null, new[]{ typeof(global::Apollo.Hdmap.LaneBoundaryType.Types.Type) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.LaneBoundary), global::Apollo.Hdmap.LaneBoundary.Parser, new[]{ "Curve", "Length", "Virtual", "BoundaryType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.LaneSampleAssociation), global::Apollo.Hdmap.LaneSampleAssociation.Parser, new[]{ "S", "Width" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Hdmap.Lane), global::Apollo.Hdmap.Lane.Parser, new[]{ "Id", "CentralCurve", "LeftBoundary", "RightBoundary", "Length", "SpeedLimit", "OverlapId", "PredecessorId", "SuccessorId", "LeftNeighborForwardLaneId", "RightNeighborForwardLaneId", "Type", "Turn", "LeftNeighborReverseLaneId", "RightNeighborReverseLaneId", "JunctionId", "LeftSample", "RightSample", "Direction", "LeftRoadSample", "RightRoadSample" }, null, new[]{ typeof(global::Apollo.Hdmap.Lane.Types.LaneType), typeof(global::Apollo.Hdmap.Lane.Types.LaneTurn), typeof(global::Apollo.Hdmap.Lane.Types.LaneDirection) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class LaneBoundaryType : pb::IMessage<LaneBoundaryType> {
    private static readonly pb::MessageParser<LaneBoundaryType> _parser = new pb::MessageParser<LaneBoundaryType>(() => new LaneBoundaryType());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LaneBoundaryType> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapLaneReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundaryType() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundaryType(LaneBoundaryType other) : this() {
      s_ = other.s_;
      types_ = other.types_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundaryType Clone() {
      return new LaneBoundaryType(this);
    }

    /// <summary>Field number for the "s" field.</summary>
    public const int SFieldNumber = 1;
    private double s_;
    /// <summary>
    /// Offset relative to the starting point of boundary
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double S {
      get { return s_; }
      set {
        s_ = value;
      }
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 2;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.LaneBoundaryType.Types.Type> _repeated_types_codec
        = pb::FieldCodec.ForEnum(18, x => (int) x, x => (global::Apollo.Hdmap.LaneBoundaryType.Types.Type) x);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.LaneBoundaryType.Types.Type> types_ = new pbc::RepeatedField<global::Apollo.Hdmap.LaneBoundaryType.Types.Type>();
    /// <summary>
    /// support multiple types
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.LaneBoundaryType.Types.Type> Types_ {
      get { return types_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LaneBoundaryType);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LaneBoundaryType other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (S != other.S) return false;
      if(!types_.Equals(other.types_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (S != 0D) hash ^= S.GetHashCode();
      hash ^= types_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (S != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(S);
      }
      types_.WriteTo(output, _repeated_types_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (S != 0D) {
        size += 1 + 8;
      }
      size += types_.CalculateSize(_repeated_types_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LaneBoundaryType other) {
      if (other == null) {
        return;
      }
      if (other.S != 0D) {
        S = other.S;
      }
      types_.Add(other.types_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            S = input.ReadDouble();
            break;
          }
          case 18:
          case 16: {
            types_.AddEntriesFrom(input, _repeated_types_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the LaneBoundaryType message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Type {
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        [pbr::OriginalName("DOTTED_YELLOW")] DottedYellow = 1,
        [pbr::OriginalName("DOTTED_WHITE")] DottedWhite = 2,
        [pbr::OriginalName("SOLID_YELLOW")] SolidYellow = 3,
        [pbr::OriginalName("SOLID_WHITE")] SolidWhite = 4,
        [pbr::OriginalName("DOUBLE_YELLOW")] DoubleYellow = 5,
        [pbr::OriginalName("CURB")] Curb = 6,
      }

    }
    #endregion

  }

  public sealed partial class LaneBoundary : pb::IMessage<LaneBoundary> {
    private static readonly pb::MessageParser<LaneBoundary> _parser = new pb::MessageParser<LaneBoundary>(() => new LaneBoundary());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LaneBoundary> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapLaneReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundary() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundary(LaneBoundary other) : this() {
      Curve = other.curve_ != null ? other.Curve.Clone() : null;
      length_ = other.length_;
      virtual_ = other.virtual_;
      boundaryType_ = other.boundaryType_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundary Clone() {
      return new LaneBoundary(this);
    }

    /// <summary>Field number for the "curve" field.</summary>
    public const int CurveFieldNumber = 1;
    private global::Apollo.Hdmap.Curve curve_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Curve Curve {
      get { return curve_; }
      set {
        curve_ = value;
      }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 2;
    private double length_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    /// <summary>Field number for the "virtual" field.</summary>
    public const int VirtualFieldNumber = 3;
    private bool virtual_;
    /// <summary>
    /// indicate whether the lane boundary exists in real world
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Virtual {
      get { return virtual_; }
      set {
        virtual_ = value;
      }
    }

    /// <summary>Field number for the "boundary_type" field.</summary>
    public const int BoundaryTypeFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.LaneBoundaryType> _repeated_boundaryType_codec
        = pb::FieldCodec.ForMessage(34, global::Apollo.Hdmap.LaneBoundaryType.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.LaneBoundaryType> boundaryType_ = new pbc::RepeatedField<global::Apollo.Hdmap.LaneBoundaryType>();
    /// <summary>
    /// in ascending order of s
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.LaneBoundaryType> BoundaryType {
      get { return boundaryType_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LaneBoundary);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LaneBoundary other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Curve, other.Curve)) return false;
      if (Length != other.Length) return false;
      if (Virtual != other.Virtual) return false;
      if(!boundaryType_.Equals(other.boundaryType_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (curve_ != null) hash ^= Curve.GetHashCode();
      if (Length != 0D) hash ^= Length.GetHashCode();
      if (Virtual != false) hash ^= Virtual.GetHashCode();
      hash ^= boundaryType_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (curve_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Curve);
      }
      if (Length != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(Length);
      }
      if (Virtual != false) {
        output.WriteRawTag(24);
        output.WriteBool(Virtual);
      }
      boundaryType_.WriteTo(output, _repeated_boundaryType_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (curve_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Curve);
      }
      if (Length != 0D) {
        size += 1 + 8;
      }
      if (Virtual != false) {
        size += 1 + 1;
      }
      size += boundaryType_.CalculateSize(_repeated_boundaryType_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LaneBoundary other) {
      if (other == null) {
        return;
      }
      if (other.curve_ != null) {
        if (curve_ == null) {
          curve_ = new global::Apollo.Hdmap.Curve();
        }
        Curve.MergeFrom(other.Curve);
      }
      if (other.Length != 0D) {
        Length = other.Length;
      }
      if (other.Virtual != false) {
        Virtual = other.Virtual;
      }
      boundaryType_.Add(other.boundaryType_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (curve_ == null) {
              curve_ = new global::Apollo.Hdmap.Curve();
            }
            input.ReadMessage(curve_);
            break;
          }
          case 17: {
            Length = input.ReadDouble();
            break;
          }
          case 24: {
            Virtual = input.ReadBool();
            break;
          }
          case 34: {
            boundaryType_.AddEntriesFrom(input, _repeated_boundaryType_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Association between central point to closest boundary.
  /// </summary>
  public sealed partial class LaneSampleAssociation : pb::IMessage<LaneSampleAssociation> {
    private static readonly pb::MessageParser<LaneSampleAssociation> _parser = new pb::MessageParser<LaneSampleAssociation>(() => new LaneSampleAssociation());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LaneSampleAssociation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapLaneReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneSampleAssociation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneSampleAssociation(LaneSampleAssociation other) : this() {
      s_ = other.s_;
      width_ = other.width_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneSampleAssociation Clone() {
      return new LaneSampleAssociation(this);
    }

    /// <summary>Field number for the "s" field.</summary>
    public const int SFieldNumber = 1;
    private double s_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double S {
      get { return s_; }
      set {
        s_ = value;
      }
    }

    /// <summary>Field number for the "width" field.</summary>
    public const int WidthFieldNumber = 2;
    private double width_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Width {
      get { return width_; }
      set {
        width_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LaneSampleAssociation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LaneSampleAssociation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (S != other.S) return false;
      if (Width != other.Width) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (S != 0D) hash ^= S.GetHashCode();
      if (Width != 0D) hash ^= Width.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (S != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(S);
      }
      if (Width != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(Width);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (S != 0D) {
        size += 1 + 8;
      }
      if (Width != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LaneSampleAssociation other) {
      if (other == null) {
        return;
      }
      if (other.S != 0D) {
        S = other.S;
      }
      if (other.Width != 0D) {
        Width = other.Width;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            S = input.ReadDouble();
            break;
          }
          case 17: {
            Width = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A lane is part of a roadway, that is designated for use by a single line of vehicles.
  /// Most public roads (include highways) have more than two lanes.
  /// </summary>
  public sealed partial class Lane : pb::IMessage<Lane> {
    private static readonly pb::MessageParser<Lane> _parser = new pb::MessageParser<Lane>(() => new Lane());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Lane> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Hdmap.MapLaneReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Lane() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Lane(Lane other) : this() {
      Id = other.id_ != null ? other.Id.Clone() : null;
      CentralCurve = other.centralCurve_ != null ? other.CentralCurve.Clone() : null;
      LeftBoundary = other.leftBoundary_ != null ? other.LeftBoundary.Clone() : null;
      RightBoundary = other.rightBoundary_ != null ? other.RightBoundary.Clone() : null;
      length_ = other.length_;
      speedLimit_ = other.speedLimit_;
      overlapId_ = other.overlapId_.Clone();
      predecessorId_ = other.predecessorId_.Clone();
      successorId_ = other.successorId_.Clone();
      leftNeighborForwardLaneId_ = other.leftNeighborForwardLaneId_.Clone();
      rightNeighborForwardLaneId_ = other.rightNeighborForwardLaneId_.Clone();
      type_ = other.type_;
      turn_ = other.turn_;
      leftNeighborReverseLaneId_ = other.leftNeighborReverseLaneId_.Clone();
      rightNeighborReverseLaneId_ = other.rightNeighborReverseLaneId_.Clone();
      JunctionId = other.junctionId_ != null ? other.JunctionId.Clone() : null;
      leftSample_ = other.leftSample_.Clone();
      rightSample_ = other.rightSample_.Clone();
      direction_ = other.direction_;
      leftRoadSample_ = other.leftRoadSample_.Clone();
      rightRoadSample_ = other.rightRoadSample_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Lane Clone() {
      return new Lane(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Apollo.Hdmap.Id id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Id Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "central_curve" field.</summary>
    public const int CentralCurveFieldNumber = 2;
    private global::Apollo.Hdmap.Curve centralCurve_;
    /// <summary>
    /// Central lane as reference trajectory, not necessary to be the geometry central.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Curve CentralCurve {
      get { return centralCurve_; }
      set {
        centralCurve_ = value;
      }
    }

    /// <summary>Field number for the "left_boundary" field.</summary>
    public const int LeftBoundaryFieldNumber = 3;
    private global::Apollo.Hdmap.LaneBoundary leftBoundary_;
    /// <summary>
    /// Lane boundary curve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.LaneBoundary LeftBoundary {
      get { return leftBoundary_; }
      set {
        leftBoundary_ = value;
      }
    }

    /// <summary>Field number for the "right_boundary" field.</summary>
    public const int RightBoundaryFieldNumber = 4;
    private global::Apollo.Hdmap.LaneBoundary rightBoundary_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.LaneBoundary RightBoundary {
      get { return rightBoundary_; }
      set {
        rightBoundary_ = value;
      }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 5;
    private double length_;
    /// <summary>
    /// in meters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    /// <summary>Field number for the "speed_limit" field.</summary>
    public const int SpeedLimitFieldNumber = 6;
    private double speedLimit_;
    /// <summary>
    /// Speed limit of the lane, in meters per second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SpeedLimit {
      get { return speedLimit_; }
      set {
        speedLimit_ = value;
      }
    }

    /// <summary>Field number for the "overlap_id" field.</summary>
    public const int OverlapIdFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_overlapId_codec
        = pb::FieldCodec.ForMessage(58, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> overlapId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> OverlapId {
      get { return overlapId_; }
    }

    /// <summary>Field number for the "predecessor_id" field.</summary>
    public const int PredecessorIdFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_predecessorId_codec
        = pb::FieldCodec.ForMessage(66, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> predecessorId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    /// <summary>
    /// All lanes can be driving into (or from).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> PredecessorId {
      get { return predecessorId_; }
    }

    /// <summary>Field number for the "successor_id" field.</summary>
    public const int SuccessorIdFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_successorId_codec
        = pb::FieldCodec.ForMessage(74, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> successorId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> SuccessorId {
      get { return successorId_; }
    }

    /// <summary>Field number for the "left_neighbor_forward_lane_id" field.</summary>
    public const int LeftNeighborForwardLaneIdFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_leftNeighborForwardLaneId_codec
        = pb::FieldCodec.ForMessage(82, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> leftNeighborForwardLaneId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    /// <summary>
    /// Neighbor lanes on the same direction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> LeftNeighborForwardLaneId {
      get { return leftNeighborForwardLaneId_; }
    }

    /// <summary>Field number for the "right_neighbor_forward_lane_id" field.</summary>
    public const int RightNeighborForwardLaneIdFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_rightNeighborForwardLaneId_codec
        = pb::FieldCodec.ForMessage(90, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> rightNeighborForwardLaneId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> RightNeighborForwardLaneId {
      get { return rightNeighborForwardLaneId_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 12;
    private global::Apollo.Hdmap.Lane.Types.LaneType type_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Lane.Types.LaneType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "turn" field.</summary>
    public const int TurnFieldNumber = 13;
    private global::Apollo.Hdmap.Lane.Types.LaneTurn turn_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Lane.Types.LaneTurn Turn {
      get { return turn_; }
      set {
        turn_ = value;
      }
    }

    /// <summary>Field number for the "left_neighbor_reverse_lane_id" field.</summary>
    public const int LeftNeighborReverseLaneIdFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_leftNeighborReverseLaneId_codec
        = pb::FieldCodec.ForMessage(114, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> leftNeighborReverseLaneId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> LeftNeighborReverseLaneId {
      get { return leftNeighborReverseLaneId_; }
    }

    /// <summary>Field number for the "right_neighbor_reverse_lane_id" field.</summary>
    public const int RightNeighborReverseLaneIdFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.Id> _repeated_rightNeighborReverseLaneId_codec
        = pb::FieldCodec.ForMessage(122, global::Apollo.Hdmap.Id.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.Id> rightNeighborReverseLaneId_ = new pbc::RepeatedField<global::Apollo.Hdmap.Id>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.Id> RightNeighborReverseLaneId {
      get { return rightNeighborReverseLaneId_; }
    }

    /// <summary>Field number for the "junction_id" field.</summary>
    public const int JunctionIdFieldNumber = 16;
    private global::Apollo.Hdmap.Id junctionId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Id JunctionId {
      get { return junctionId_; }
      set {
        junctionId_ = value;
      }
    }

    /// <summary>Field number for the "left_sample" field.</summary>
    public const int LeftSampleFieldNumber = 17;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.LaneSampleAssociation> _repeated_leftSample_codec
        = pb::FieldCodec.ForMessage(138, global::Apollo.Hdmap.LaneSampleAssociation.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> leftSample_ = new pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation>();
    /// <summary>
    /// Association between central point to closest boundary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> LeftSample {
      get { return leftSample_; }
    }

    /// <summary>Field number for the "right_sample" field.</summary>
    public const int RightSampleFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.LaneSampleAssociation> _repeated_rightSample_codec
        = pb::FieldCodec.ForMessage(146, global::Apollo.Hdmap.LaneSampleAssociation.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> rightSample_ = new pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> RightSample {
      get { return rightSample_; }
    }

    /// <summary>Field number for the "direction" field.</summary>
    public const int DirectionFieldNumber = 19;
    private global::Apollo.Hdmap.Lane.Types.LaneDirection direction_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Hdmap.Lane.Types.LaneDirection Direction {
      get { return direction_; }
      set {
        direction_ = value;
      }
    }

    /// <summary>Field number for the "left_road_sample" field.</summary>
    public const int LeftRoadSampleFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.LaneSampleAssociation> _repeated_leftRoadSample_codec
        = pb::FieldCodec.ForMessage(162, global::Apollo.Hdmap.LaneSampleAssociation.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> leftRoadSample_ = new pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation>();
    /// <summary>
    /// Association between central point to closest road boundary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> LeftRoadSample {
      get { return leftRoadSample_; }
    }

    /// <summary>Field number for the "right_road_sample" field.</summary>
    public const int RightRoadSampleFieldNumber = 21;
    private static readonly pb::FieldCodec<global::Apollo.Hdmap.LaneSampleAssociation> _repeated_rightRoadSample_codec
        = pb::FieldCodec.ForMessage(170, global::Apollo.Hdmap.LaneSampleAssociation.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> rightRoadSample_ = new pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Hdmap.LaneSampleAssociation> RightRoadSample {
      get { return rightRoadSample_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Lane);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Lane other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(CentralCurve, other.CentralCurve)) return false;
      if (!object.Equals(LeftBoundary, other.LeftBoundary)) return false;
      if (!object.Equals(RightBoundary, other.RightBoundary)) return false;
      if (Length != other.Length) return false;
      if (SpeedLimit != other.SpeedLimit) return false;
      if(!overlapId_.Equals(other.overlapId_)) return false;
      if(!predecessorId_.Equals(other.predecessorId_)) return false;
      if(!successorId_.Equals(other.successorId_)) return false;
      if(!leftNeighborForwardLaneId_.Equals(other.leftNeighborForwardLaneId_)) return false;
      if(!rightNeighborForwardLaneId_.Equals(other.rightNeighborForwardLaneId_)) return false;
      if (Type != other.Type) return false;
      if (Turn != other.Turn) return false;
      if(!leftNeighborReverseLaneId_.Equals(other.leftNeighborReverseLaneId_)) return false;
      if(!rightNeighborReverseLaneId_.Equals(other.rightNeighborReverseLaneId_)) return false;
      if (!object.Equals(JunctionId, other.JunctionId)) return false;
      if(!leftSample_.Equals(other.leftSample_)) return false;
      if(!rightSample_.Equals(other.rightSample_)) return false;
      if (Direction != other.Direction) return false;
      if(!leftRoadSample_.Equals(other.leftRoadSample_)) return false;
      if(!rightRoadSample_.Equals(other.rightRoadSample_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (centralCurve_ != null) hash ^= CentralCurve.GetHashCode();
      if (leftBoundary_ != null) hash ^= LeftBoundary.GetHashCode();
      if (rightBoundary_ != null) hash ^= RightBoundary.GetHashCode();
      if (Length != 0D) hash ^= Length.GetHashCode();
      if (SpeedLimit != 0D) hash ^= SpeedLimit.GetHashCode();
      hash ^= overlapId_.GetHashCode();
      hash ^= predecessorId_.GetHashCode();
      hash ^= successorId_.GetHashCode();
      hash ^= leftNeighborForwardLaneId_.GetHashCode();
      hash ^= rightNeighborForwardLaneId_.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (Turn != 0) hash ^= Turn.GetHashCode();
      hash ^= leftNeighborReverseLaneId_.GetHashCode();
      hash ^= rightNeighborReverseLaneId_.GetHashCode();
      if (junctionId_ != null) hash ^= JunctionId.GetHashCode();
      hash ^= leftSample_.GetHashCode();
      hash ^= rightSample_.GetHashCode();
      if (Direction != 0) hash ^= Direction.GetHashCode();
      hash ^= leftRoadSample_.GetHashCode();
      hash ^= rightRoadSample_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (centralCurve_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CentralCurve);
      }
      if (leftBoundary_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LeftBoundary);
      }
      if (rightBoundary_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(RightBoundary);
      }
      if (Length != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(Length);
      }
      if (SpeedLimit != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(SpeedLimit);
      }
      overlapId_.WriteTo(output, _repeated_overlapId_codec);
      predecessorId_.WriteTo(output, _repeated_predecessorId_codec);
      successorId_.WriteTo(output, _repeated_successorId_codec);
      leftNeighborForwardLaneId_.WriteTo(output, _repeated_leftNeighborForwardLaneId_codec);
      rightNeighborForwardLaneId_.WriteTo(output, _repeated_rightNeighborForwardLaneId_codec);
      if (Type != 0) {
        output.WriteRawTag(96);
        output.WriteEnum((int) Type);
      }
      if (Turn != 0) {
        output.WriteRawTag(104);
        output.WriteEnum((int) Turn);
      }
      leftNeighborReverseLaneId_.WriteTo(output, _repeated_leftNeighborReverseLaneId_codec);
      rightNeighborReverseLaneId_.WriteTo(output, _repeated_rightNeighborReverseLaneId_codec);
      if (junctionId_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(JunctionId);
      }
      leftSample_.WriteTo(output, _repeated_leftSample_codec);
      rightSample_.WriteTo(output, _repeated_rightSample_codec);
      if (Direction != 0) {
        output.WriteRawTag(152, 1);
        output.WriteEnum((int) Direction);
      }
      leftRoadSample_.WriteTo(output, _repeated_leftRoadSample_codec);
      rightRoadSample_.WriteTo(output, _repeated_rightRoadSample_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (centralCurve_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CentralCurve);
      }
      if (leftBoundary_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LeftBoundary);
      }
      if (rightBoundary_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RightBoundary);
      }
      if (Length != 0D) {
        size += 1 + 8;
      }
      if (SpeedLimit != 0D) {
        size += 1 + 8;
      }
      size += overlapId_.CalculateSize(_repeated_overlapId_codec);
      size += predecessorId_.CalculateSize(_repeated_predecessorId_codec);
      size += successorId_.CalculateSize(_repeated_successorId_codec);
      size += leftNeighborForwardLaneId_.CalculateSize(_repeated_leftNeighborForwardLaneId_codec);
      size += rightNeighborForwardLaneId_.CalculateSize(_repeated_rightNeighborForwardLaneId_codec);
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Turn != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Turn);
      }
      size += leftNeighborReverseLaneId_.CalculateSize(_repeated_leftNeighborReverseLaneId_codec);
      size += rightNeighborReverseLaneId_.CalculateSize(_repeated_rightNeighborReverseLaneId_codec);
      if (junctionId_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(JunctionId);
      }
      size += leftSample_.CalculateSize(_repeated_leftSample_codec);
      size += rightSample_.CalculateSize(_repeated_rightSample_codec);
      if (Direction != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Direction);
      }
      size += leftRoadSample_.CalculateSize(_repeated_leftRoadSample_codec);
      size += rightRoadSample_.CalculateSize(_repeated_rightRoadSample_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Lane other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          id_ = new global::Apollo.Hdmap.Id();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.centralCurve_ != null) {
        if (centralCurve_ == null) {
          centralCurve_ = new global::Apollo.Hdmap.Curve();
        }
        CentralCurve.MergeFrom(other.CentralCurve);
      }
      if (other.leftBoundary_ != null) {
        if (leftBoundary_ == null) {
          leftBoundary_ = new global::Apollo.Hdmap.LaneBoundary();
        }
        LeftBoundary.MergeFrom(other.LeftBoundary);
      }
      if (other.rightBoundary_ != null) {
        if (rightBoundary_ == null) {
          rightBoundary_ = new global::Apollo.Hdmap.LaneBoundary();
        }
        RightBoundary.MergeFrom(other.RightBoundary);
      }
      if (other.Length != 0D) {
        Length = other.Length;
      }
      if (other.SpeedLimit != 0D) {
        SpeedLimit = other.SpeedLimit;
      }
      overlapId_.Add(other.overlapId_);
      predecessorId_.Add(other.predecessorId_);
      successorId_.Add(other.successorId_);
      leftNeighborForwardLaneId_.Add(other.leftNeighborForwardLaneId_);
      rightNeighborForwardLaneId_.Add(other.rightNeighborForwardLaneId_);
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.Turn != 0) {
        Turn = other.Turn;
      }
      leftNeighborReverseLaneId_.Add(other.leftNeighborReverseLaneId_);
      rightNeighborReverseLaneId_.Add(other.rightNeighborReverseLaneId_);
      if (other.junctionId_ != null) {
        if (junctionId_ == null) {
          junctionId_ = new global::Apollo.Hdmap.Id();
        }
        JunctionId.MergeFrom(other.JunctionId);
      }
      leftSample_.Add(other.leftSample_);
      rightSample_.Add(other.rightSample_);
      if (other.Direction != 0) {
        Direction = other.Direction;
      }
      leftRoadSample_.Add(other.leftRoadSample_);
      rightRoadSample_.Add(other.rightRoadSample_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (id_ == null) {
              id_ = new global::Apollo.Hdmap.Id();
            }
            input.ReadMessage(id_);
            break;
          }
          case 18: {
            if (centralCurve_ == null) {
              centralCurve_ = new global::Apollo.Hdmap.Curve();
            }
            input.ReadMessage(centralCurve_);
            break;
          }
          case 26: {
            if (leftBoundary_ == null) {
              leftBoundary_ = new global::Apollo.Hdmap.LaneBoundary();
            }
            input.ReadMessage(leftBoundary_);
            break;
          }
          case 34: {
            if (rightBoundary_ == null) {
              rightBoundary_ = new global::Apollo.Hdmap.LaneBoundary();
            }
            input.ReadMessage(rightBoundary_);
            break;
          }
          case 41: {
            Length = input.ReadDouble();
            break;
          }
          case 49: {
            SpeedLimit = input.ReadDouble();
            break;
          }
          case 58: {
            overlapId_.AddEntriesFrom(input, _repeated_overlapId_codec);
            break;
          }
          case 66: {
            predecessorId_.AddEntriesFrom(input, _repeated_predecessorId_codec);
            break;
          }
          case 74: {
            successorId_.AddEntriesFrom(input, _repeated_successorId_codec);
            break;
          }
          case 82: {
            leftNeighborForwardLaneId_.AddEntriesFrom(input, _repeated_leftNeighborForwardLaneId_codec);
            break;
          }
          case 90: {
            rightNeighborForwardLaneId_.AddEntriesFrom(input, _repeated_rightNeighborForwardLaneId_codec);
            break;
          }
          case 96: {
            type_ = (global::Apollo.Hdmap.Lane.Types.LaneType) input.ReadEnum();
            break;
          }
          case 104: {
            turn_ = (global::Apollo.Hdmap.Lane.Types.LaneTurn) input.ReadEnum();
            break;
          }
          case 114: {
            leftNeighborReverseLaneId_.AddEntriesFrom(input, _repeated_leftNeighborReverseLaneId_codec);
            break;
          }
          case 122: {
            rightNeighborReverseLaneId_.AddEntriesFrom(input, _repeated_rightNeighborReverseLaneId_codec);
            break;
          }
          case 130: {
            if (junctionId_ == null) {
              junctionId_ = new global::Apollo.Hdmap.Id();
            }
            input.ReadMessage(junctionId_);
            break;
          }
          case 138: {
            leftSample_.AddEntriesFrom(input, _repeated_leftSample_codec);
            break;
          }
          case 146: {
            rightSample_.AddEntriesFrom(input, _repeated_rightSample_codec);
            break;
          }
          case 152: {
            direction_ = (global::Apollo.Hdmap.Lane.Types.LaneDirection) input.ReadEnum();
            break;
          }
          case 162: {
            leftRoadSample_.AddEntriesFrom(input, _repeated_leftRoadSample_codec);
            break;
          }
          case 170: {
            rightRoadSample_.AddEntriesFrom(input, _repeated_rightRoadSample_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Lane message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum LaneType {
        [pbr::OriginalName("LANETYPE_DUMMY")] Dummy = 0,
        [pbr::OriginalName("NONE")] None = 1,
        [pbr::OriginalName("CITY_DRIVING")] CityDriving = 2,
        [pbr::OriginalName("BIKING")] Biking = 3,
        [pbr::OriginalName("SIDEWALK")] Sidewalk = 4,
        [pbr::OriginalName("PARKING")] Parking = 5,
        [pbr::OriginalName("SHOULDER")] Shoulder = 6,
      }

      public enum LaneTurn {
        [pbr::OriginalName("LANETURN_DUMMY")] Dummy = 0,
        [pbr::OriginalName("NO_TURN")] NoTurn = 1,
        [pbr::OriginalName("LEFT_TURN")] LeftTurn = 2,
        [pbr::OriginalName("RIGHT_TURN")] RightTurn = 3,
        [pbr::OriginalName("U_TURN")] UTurn = 4,
      }

      public enum LaneDirection {
        [pbr::OriginalName("LANEDIRECTION_DUMMY")] Dummy = 0,
        [pbr::OriginalName("FORWARD")] Forward = 1,
        [pbr::OriginalName("BACKWARD")] Backward = 2,
        [pbr::OriginalName("BIDIRECTION")] Bidirection = 3,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
