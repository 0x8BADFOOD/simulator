// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/decider_config.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Apollo.Planning {

  /// <summary>Holder for reflection information generated from modules/planning/proto/decider_config.proto</summary>
  public static partial class DeciderConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for modules/planning/proto/decider_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DeciderConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cittb2R1bGVzL3BsYW5uaW5nL3Byb3RvL2RlY2lkZXJfY29uZmlnLnByb3Rv",
            "Eg9hcG9sbG8ucGxhbm5pbmciswEKEkRlY2lkZXJDcmVlcENvbmZpZxIVCg1z",
            "dG9wX2Rpc3RhbmNlGAEgASgBEhMKC3NwZWVkX2xpbWl0GAIgASgBEh8KF21h",
            "eF92YWxpZF9zdG9wX2Rpc3RhbmNlGAMgASgBEhYKDm1pbl9ib3VuZGFyeV90",
            "GAQgASgBEhsKE2lnbm9yZV9tYXhfc3RfbWluX3QYBSABKAESGwoTaWdub3Jl",
            "X21pbl9zdF9taW5fcxgGIAEoASI9ChNSdWxlQ3Jvc3N3YWxrQ29uZmlnEg8K",
            "B2VuYWJsZWQYASABKAgSFQoNc3RvcF9kaXN0YW5jZRgCIAEoASI8ChJSdWxl",
            "U3RvcFNpZ25Db25maWcSDwoHZW5hYmxlZBgBIAEoCBIVCg1zdG9wX2Rpc3Rh",
            "bmNlGAIgASgBImAKFlJ1bGVUcmFmZmljTGlnaHRDb25maWcSDwoHZW5hYmxl",
            "ZBgBIAEoCBIVCg1zdG9wX2Rpc3RhbmNlGAIgASgBEh4KFnNpZ25hbF9leHBp",
            "cmVfdGltZV9zZWMYAyABKAEizQEKGkRlY2lkZXJSdWxlQmFzZWRTdG9wQ29u",
            "ZmlnEjcKCWNyb3Nzd2FsaxgBIAEoCzIkLmFwb2xsby5wbGFubmluZy5SdWxl",
            "Q3Jvc3N3YWxrQ29uZmlnEjYKCXN0b3Bfc2lnbhgCIAEoCzIjLmFwb2xsby5w",
            "bGFubmluZy5SdWxlU3RvcFNpZ25Db25maWcSPgoNdHJhZmZpY19saWdodBgD",
            "IAEoCzInLmFwb2xsby5wbGFubmluZy5SdWxlVHJhZmZpY0xpZ2h0Q29uZmln",
            "IoABChRTaWRlUGFzc1NhZmV0eUNvbmZpZxIlCh1taW5fb2JzdGFjbGVfbGF0",
            "ZXJhbF9kaXN0YW5jZRgBIAEoARIbChNtYXhfb3ZlcmxhcF9zX3JhbmdlGAIg",
            "ASgBEiQKHHNhZmVfZHVyYXRpb25fcmVhY2hfcmVmX2xpbmUYAyABKAFiBnBy",
            "b3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.DeciderCreepConfig), global::Apollo.Planning.DeciderCreepConfig.Parser, new[]{ "StopDistance", "SpeedLimit", "MaxValidStopDistance", "MinBoundaryT", "IgnoreMaxStMinT", "IgnoreMinStMinS" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.RuleCrosswalkConfig), global::Apollo.Planning.RuleCrosswalkConfig.Parser, new[]{ "Enabled", "StopDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.RuleStopSignConfig), global::Apollo.Planning.RuleStopSignConfig.Parser, new[]{ "Enabled", "StopDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.RuleTrafficLightConfig), global::Apollo.Planning.RuleTrafficLightConfig.Parser, new[]{ "Enabled", "StopDistance", "SignalExpireTimeSec" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.DeciderRuleBasedStopConfig), global::Apollo.Planning.DeciderRuleBasedStopConfig.Parser, new[]{ "Crosswalk", "StopSign", "TrafficLight" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.SidePassSafetyConfig), global::Apollo.Planning.SidePassSafetyConfig.Parser, new[]{ "MinObstacleLateralDistance", "MaxOverlapSRange", "SafeDurationReachRefLine" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class DeciderCreepConfig : pb::IMessage<DeciderCreepConfig> {
    private static readonly pb::MessageParser<DeciderCreepConfig> _parser = new pb::MessageParser<DeciderCreepConfig>(() => new DeciderCreepConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeciderCreepConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.DeciderConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeciderCreepConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeciderCreepConfig(DeciderCreepConfig other) : this() {
      stopDistance_ = other.stopDistance_;
      speedLimit_ = other.speedLimit_;
      maxValidStopDistance_ = other.maxValidStopDistance_;
      minBoundaryT_ = other.minBoundaryT_;
      ignoreMaxStMinT_ = other.ignoreMaxStMinT_;
      ignoreMinStMinS_ = other.ignoreMinStMinS_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeciderCreepConfig Clone() {
      return new DeciderCreepConfig(this);
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 1;
    private double stopDistance_;
    /// <summary>
    /// stop distance(m) to the creeping stop fence while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "speed_limit" field.</summary>
    public const int SpeedLimitFieldNumber = 2;
    private double speedLimit_;
    /// <summary>
    /// m/s
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SpeedLimit {
      get { return speedLimit_; }
      set {
        speedLimit_ = value;
      }
    }

    /// <summary>Field number for the "max_valid_stop_distance" field.</summary>
    public const int MaxValidStopDistanceFieldNumber = 3;
    private double maxValidStopDistance_;
    /// <summary>
    /// max distance(m) to the to the creeping stop fence
    /// to be considered as a valid stop for creep
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxValidStopDistance {
      get { return maxValidStopDistance_; }
      set {
        maxValidStopDistance_ = value;
      }
    }

    /// <summary>Field number for the "min_boundary_t" field.</summary>
    public const int MinBoundaryTFieldNumber = 4;
    private double minBoundaryT_;
    /// <summary>
    /// min boundary t to ignore obstacles while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinBoundaryT {
      get { return minBoundaryT_; }
      set {
        minBoundaryT_ = value;
      }
    }

    /// <summary>Field number for the "ignore_max_st_min_t" field.</summary>
    public const int IgnoreMaxStMinTFieldNumber = 5;
    private double ignoreMaxStMinT_;
    /// <summary>
    /// tolerance min_t &amp; min_s to ignore obstacles which are moving
    /// on same direction of ADC while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double IgnoreMaxStMinT {
      get { return ignoreMaxStMinT_; }
      set {
        ignoreMaxStMinT_ = value;
      }
    }

    /// <summary>Field number for the "ignore_min_st_min_s" field.</summary>
    public const int IgnoreMinStMinSFieldNumber = 6;
    private double ignoreMinStMinS_;
    /// <summary>
    /// meter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double IgnoreMinStMinS {
      get { return ignoreMinStMinS_; }
      set {
        ignoreMinStMinS_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeciderCreepConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeciderCreepConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StopDistance != other.StopDistance) return false;
      if (SpeedLimit != other.SpeedLimit) return false;
      if (MaxValidStopDistance != other.MaxValidStopDistance) return false;
      if (MinBoundaryT != other.MinBoundaryT) return false;
      if (IgnoreMaxStMinT != other.IgnoreMaxStMinT) return false;
      if (IgnoreMinStMinS != other.IgnoreMinStMinS) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (SpeedLimit != 0D) hash ^= SpeedLimit.GetHashCode();
      if (MaxValidStopDistance != 0D) hash ^= MaxValidStopDistance.GetHashCode();
      if (MinBoundaryT != 0D) hash ^= MinBoundaryT.GetHashCode();
      if (IgnoreMaxStMinT != 0D) hash ^= IgnoreMaxStMinT.GetHashCode();
      if (IgnoreMinStMinS != 0D) hash ^= IgnoreMinStMinS.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StopDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(StopDistance);
      }
      if (SpeedLimit != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(SpeedLimit);
      }
      if (MaxValidStopDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(MaxValidStopDistance);
      }
      if (MinBoundaryT != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(MinBoundaryT);
      }
      if (IgnoreMaxStMinT != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(IgnoreMaxStMinT);
      }
      if (IgnoreMinStMinS != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(IgnoreMinStMinS);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (SpeedLimit != 0D) {
        size += 1 + 8;
      }
      if (MaxValidStopDistance != 0D) {
        size += 1 + 8;
      }
      if (MinBoundaryT != 0D) {
        size += 1 + 8;
      }
      if (IgnoreMaxStMinT != 0D) {
        size += 1 + 8;
      }
      if (IgnoreMinStMinS != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeciderCreepConfig other) {
      if (other == null) {
        return;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.SpeedLimit != 0D) {
        SpeedLimit = other.SpeedLimit;
      }
      if (other.MaxValidStopDistance != 0D) {
        MaxValidStopDistance = other.MaxValidStopDistance;
      }
      if (other.MinBoundaryT != 0D) {
        MinBoundaryT = other.MinBoundaryT;
      }
      if (other.IgnoreMaxStMinT != 0D) {
        IgnoreMaxStMinT = other.IgnoreMaxStMinT;
      }
      if (other.IgnoreMinStMinS != 0D) {
        IgnoreMinStMinS = other.IgnoreMinStMinS;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 17: {
            SpeedLimit = input.ReadDouble();
            break;
          }
          case 25: {
            MaxValidStopDistance = input.ReadDouble();
            break;
          }
          case 33: {
            MinBoundaryT = input.ReadDouble();
            break;
          }
          case 41: {
            IgnoreMaxStMinT = input.ReadDouble();
            break;
          }
          case 49: {
            IgnoreMinStMinS = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class RuleCrosswalkConfig : pb::IMessage<RuleCrosswalkConfig> {
    private static readonly pb::MessageParser<RuleCrosswalkConfig> _parser = new pb::MessageParser<RuleCrosswalkConfig>(() => new RuleCrosswalkConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RuleCrosswalkConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.DeciderConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleCrosswalkConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleCrosswalkConfig(RuleCrosswalkConfig other) : this() {
      enabled_ = other.enabled_;
      stopDistance_ = other.stopDistance_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleCrosswalkConfig Clone() {
      return new RuleCrosswalkConfig(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 2;
    private double stopDistance_;
    /// <summary>
    /// stop distance(m) to the stop line of the crosswalk
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RuleCrosswalkConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RuleCrosswalkConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (StopDistance != other.StopDistance) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (StopDistance != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(StopDistance);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RuleCrosswalkConfig other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 17: {
            StopDistance = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class RuleStopSignConfig : pb::IMessage<RuleStopSignConfig> {
    private static readonly pb::MessageParser<RuleStopSignConfig> _parser = new pb::MessageParser<RuleStopSignConfig>(() => new RuleStopSignConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RuleStopSignConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.DeciderConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleStopSignConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleStopSignConfig(RuleStopSignConfig other) : this() {
      enabled_ = other.enabled_;
      stopDistance_ = other.stopDistance_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleStopSignConfig Clone() {
      return new RuleStopSignConfig(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 2;
    private double stopDistance_;
    /// <summary>
    /// stop distance(m) to the stop line of the stop sign
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RuleStopSignConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RuleStopSignConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (StopDistance != other.StopDistance) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (StopDistance != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(StopDistance);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RuleStopSignConfig other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 17: {
            StopDistance = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class RuleTrafficLightConfig : pb::IMessage<RuleTrafficLightConfig> {
    private static readonly pb::MessageParser<RuleTrafficLightConfig> _parser = new pb::MessageParser<RuleTrafficLightConfig>(() => new RuleTrafficLightConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RuleTrafficLightConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.DeciderConfigReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleTrafficLightConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleTrafficLightConfig(RuleTrafficLightConfig other) : this() {
      enabled_ = other.enabled_;
      stopDistance_ = other.stopDistance_;
      signalExpireTimeSec_ = other.signalExpireTimeSec_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleTrafficLightConfig Clone() {
      return new RuleTrafficLightConfig(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 2;
    private double stopDistance_;
    /// <summary>
    /// stop distance(m) to the stop line of the traffic light
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "signal_expire_time_sec" field.</summary>
    public const int SignalExpireTimeSecFieldNumber = 3;
    private double signalExpireTimeSec_;
    /// <summary>
    /// second
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SignalExpireTimeSec {
      get { return signalExpireTimeSec_; }
      set {
        signalExpireTimeSec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RuleTrafficLightConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RuleTrafficLightConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (StopDistance != other.StopDistance) return false;
      if (SignalExpireTimeSec != other.SignalExpireTimeSec) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (SignalExpireTimeSec != 0D) hash ^= SignalExpireTimeSec.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (StopDistance != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(StopDistance);
      }
      if (SignalExpireTimeSec != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(SignalExpireTimeSec);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (SignalExpireTimeSec != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RuleTrafficLightConfig other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.SignalExpireTimeSec != 0D) {
        SignalExpireTimeSec = other.SignalExpireTimeSec;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 17: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 25: {
            SignalExpireTimeSec = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class DeciderRuleBasedStopConfig : pb::IMessage<DeciderRuleBasedStopConfig> {
    private static readonly pb::MessageParser<DeciderRuleBasedStopConfig> _parser = new pb::MessageParser<DeciderRuleBasedStopConfig>(() => new DeciderRuleBasedStopConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeciderRuleBasedStopConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.DeciderConfigReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeciderRuleBasedStopConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeciderRuleBasedStopConfig(DeciderRuleBasedStopConfig other) : this() {
      Crosswalk = other.crosswalk_ != null ? other.Crosswalk.Clone() : null;
      StopSign = other.stopSign_ != null ? other.StopSign.Clone() : null;
      TrafficLight = other.trafficLight_ != null ? other.TrafficLight.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeciderRuleBasedStopConfig Clone() {
      return new DeciderRuleBasedStopConfig(this);
    }

    /// <summary>Field number for the "crosswalk" field.</summary>
    public const int CrosswalkFieldNumber = 1;
    private global::Apollo.Planning.RuleCrosswalkConfig crosswalk_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.RuleCrosswalkConfig Crosswalk {
      get { return crosswalk_; }
      set {
        crosswalk_ = value;
      }
    }

    /// <summary>Field number for the "stop_sign" field.</summary>
    public const int StopSignFieldNumber = 2;
    private global::Apollo.Planning.RuleStopSignConfig stopSign_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.RuleStopSignConfig StopSign {
      get { return stopSign_; }
      set {
        stopSign_ = value;
      }
    }

    /// <summary>Field number for the "traffic_light" field.</summary>
    public const int TrafficLightFieldNumber = 3;
    private global::Apollo.Planning.RuleTrafficLightConfig trafficLight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.RuleTrafficLightConfig TrafficLight {
      get { return trafficLight_; }
      set {
        trafficLight_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeciderRuleBasedStopConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeciderRuleBasedStopConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Crosswalk, other.Crosswalk)) return false;
      if (!object.Equals(StopSign, other.StopSign)) return false;
      if (!object.Equals(TrafficLight, other.TrafficLight)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (crosswalk_ != null) hash ^= Crosswalk.GetHashCode();
      if (stopSign_ != null) hash ^= StopSign.GetHashCode();
      if (trafficLight_ != null) hash ^= TrafficLight.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (crosswalk_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Crosswalk);
      }
      if (stopSign_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(StopSign);
      }
      if (trafficLight_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TrafficLight);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (crosswalk_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Crosswalk);
      }
      if (stopSign_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StopSign);
      }
      if (trafficLight_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrafficLight);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeciderRuleBasedStopConfig other) {
      if (other == null) {
        return;
      }
      if (other.crosswalk_ != null) {
        if (crosswalk_ == null) {
          crosswalk_ = new global::Apollo.Planning.RuleCrosswalkConfig();
        }
        Crosswalk.MergeFrom(other.Crosswalk);
      }
      if (other.stopSign_ != null) {
        if (stopSign_ == null) {
          stopSign_ = new global::Apollo.Planning.RuleStopSignConfig();
        }
        StopSign.MergeFrom(other.StopSign);
      }
      if (other.trafficLight_ != null) {
        if (trafficLight_ == null) {
          trafficLight_ = new global::Apollo.Planning.RuleTrafficLightConfig();
        }
        TrafficLight.MergeFrom(other.TrafficLight);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (crosswalk_ == null) {
              crosswalk_ = new global::Apollo.Planning.RuleCrosswalkConfig();
            }
            input.ReadMessage(crosswalk_);
            break;
          }
          case 18: {
            if (stopSign_ == null) {
              stopSign_ = new global::Apollo.Planning.RuleStopSignConfig();
            }
            input.ReadMessage(stopSign_);
            break;
          }
          case 26: {
            if (trafficLight_ == null) {
              trafficLight_ = new global::Apollo.Planning.RuleTrafficLightConfig();
            }
            input.ReadMessage(trafficLight_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class SidePassSafetyConfig : pb::IMessage<SidePassSafetyConfig> {
    private static readonly pb::MessageParser<SidePassSafetyConfig> _parser = new pb::MessageParser<SidePassSafetyConfig>(() => new SidePassSafetyConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SidePassSafetyConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.DeciderConfigReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SidePassSafetyConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SidePassSafetyConfig(SidePassSafetyConfig other) : this() {
      minObstacleLateralDistance_ = other.minObstacleLateralDistance_;
      maxOverlapSRange_ = other.maxOverlapSRange_;
      safeDurationReachRefLine_ = other.safeDurationReachRefLine_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SidePassSafetyConfig Clone() {
      return new SidePassSafetyConfig(this);
    }

    /// <summary>Field number for the "min_obstacle_lateral_distance" field.</summary>
    public const int MinObstacleLateralDistanceFieldNumber = 1;
    private double minObstacleLateralDistance_;
    /// <summary>
    /// min lateral distance(m) for safe obstacle
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinObstacleLateralDistance {
      get { return minObstacleLateralDistance_; }
      set {
        minObstacleLateralDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_overlap_s_range" field.</summary>
    public const int MaxOverlapSRangeFieldNumber = 2;
    private double maxOverlapSRange_;
    /// <summary>
    /// meter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxOverlapSRange {
      get { return maxOverlapSRange_; }
      set {
        maxOverlapSRange_ = value;
      }
    }

    /// <summary>Field number for the "safe_duration_reach_ref_line" field.</summary>
    public const int SafeDurationReachRefLineFieldNumber = 3;
    private double safeDurationReachRefLine_;
    /// <summary>
    ///second
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SafeDurationReachRefLine {
      get { return safeDurationReachRefLine_; }
      set {
        safeDurationReachRefLine_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SidePassSafetyConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SidePassSafetyConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinObstacleLateralDistance != other.MinObstacleLateralDistance) return false;
      if (MaxOverlapSRange != other.MaxOverlapSRange) return false;
      if (SafeDurationReachRefLine != other.SafeDurationReachRefLine) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObstacleLateralDistance != 0D) hash ^= MinObstacleLateralDistance.GetHashCode();
      if (MaxOverlapSRange != 0D) hash ^= MaxOverlapSRange.GetHashCode();
      if (SafeDurationReachRefLine != 0D) hash ^= SafeDurationReachRefLine.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObstacleLateralDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(MinObstacleLateralDistance);
      }
      if (MaxOverlapSRange != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(MaxOverlapSRange);
      }
      if (SafeDurationReachRefLine != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(SafeDurationReachRefLine);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObstacleLateralDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxOverlapSRange != 0D) {
        size += 1 + 8;
      }
      if (SafeDurationReachRefLine != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SidePassSafetyConfig other) {
      if (other == null) {
        return;
      }
      if (other.MinObstacleLateralDistance != 0D) {
        MinObstacleLateralDistance = other.MinObstacleLateralDistance;
      }
      if (other.MaxOverlapSRange != 0D) {
        MaxOverlapSRange = other.MaxOverlapSRange;
      }
      if (other.SafeDurationReachRefLine != 0D) {
        SafeDurationReachRefLine = other.SafeDurationReachRefLine;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            MinObstacleLateralDistance = input.ReadDouble();
            break;
          }
          case 17: {
            MaxOverlapSRange = input.ReadDouble();
            break;
          }
          case 25: {
            SafeDurationReachRefLine = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
