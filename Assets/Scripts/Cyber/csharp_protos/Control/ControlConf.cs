// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/control/proto/control_conf.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Apollo.Control {

  /// <summary>Holder for reflection information generated from modules/control/proto/control_conf.proto</summary>
  public static partial class ControlConfReflection {

    #region Descriptor
    /// <summary>File descriptor for modules/control/proto/control_conf.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ControlConfReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cihtb2R1bGVzL2NvbnRyb2wvcHJvdG8vY29udHJvbF9jb25mLnByb3RvEg5h",
            "cG9sbG8uY29udHJvbBoibW9kdWxlcy9jYW5idXMvcHJvdG8vY2hhc3Npcy5w",
            "cm90bxojbW9kdWxlcy9jb250cm9sL3Byb3RvL3BhZF9tc2cucHJvdG8aL21v",
            "ZHVsZXMvY29udHJvbC9wcm90by9sYXRfY29udHJvbGxlcl9jb25mLnByb3Rv",
            "Gi9tb2R1bGVzL2NvbnRyb2wvcHJvdG8vbG9uX2NvbnRyb2xsZXJfY29uZi5w",
            "cm90bxovbW9kdWxlcy9jb250cm9sL3Byb3RvL21wY19jb250cm9sbGVyX2Nv",
            "bmYucHJvdG8imAsKC0NvbnRyb2xDb25mEh0KFWNvbnRyb2xfdGVzdF9kdXJh",
            "dGlvbhgBIAEoARIYChBlbmFibGVfY3N2X2RlYnVnGAIgASgIEiQKHGVuYWJs",
            "ZV9zcGVlZF9zdGF0aW9uX3ByZXZpZXcYAyABKAgSHAoUaXNfY29udHJvbF90",
            "ZXN0X21vZGUYBCABKAgSIwobdXNlX3ByZXZpZXdfc3BlZWRfZm9yX3RhYmxl",
            "GAUgASgIEiQKHGVuYWJsZV9pbnB1dF90aW1lc3RhbXBfY2hlY2sYBiABKAgS",
            "IQoZbWF4X2xvY2FsaXphdGlvbl9taXNzX251bRgHIAEoBRIcChRtYXhfY2hh",
            "c3Npc19taXNzX251bRgIIAEoBRIdChVtYXhfcGxhbm5pbmdfbWlzc19udW0Y",
            "CSABKAUSJQodbWF4X2FjY2VsZXJhdGlvbl93aGVuX3N0b3BwZWQYCiABKAES",
            "GAoQc3RlZXJfYW5nbGVfcmF0ZRgLIAEoARIdChVlbmFibGVfZ2Fpbl9zY2hl",
            "ZHVsZXIYDCABKAgSFwoPc2V0X3N0ZWVyX2xpbWl0GA0gASgIEhsKE2VuYWJs",
            "ZV9zbG9wZV9vZmZzZXQYDiABKAgSGAoQbG9ja19zdGVlcl9zcGVlZBgPIAEo",
            "ARIrCiNlbmFibGVfbmF2aWdhdGlvbl9tb2RlX2Vycm9yX2ZpbHRlchgQIAEo",
            "CBIuCiZlbmFibGVfbmF2aWdhdGlvbl9tb2RlX3Bvc2l0aW9uX3VwZGF0ZRgR",
            "IAEoCBIfChdlbmFibGVfcGVyc2lzdGVudF9lc3RvcBgSIAEoCBIWCg5jb250",
            "cm9sX3BlcmlvZBgTIAEoARIhChltYXhfcGxhbm5pbmdfaW50ZXJ2YWxfc2Vj",
            "GBQgASgBEiQKHG1heF9wbGFubmluZ19kZWxheV90aHJlc2hvbGQYFSABKAES",
            "OAoMZHJpdmluZ19tb2RlGBYgASgOMiIuYXBvbGxvLmNhbmJ1cy5DaGFzc2lz",
            "LkRyaXZpbmdNb2RlEi0KBmFjdGlvbhgXIAEoDjIdLmFwb2xsby5jb250cm9s",
            "LkRyaXZpbmdBY3Rpb24SGAoQc29mdF9lc3RvcF9icmFrZRgYIAEoARJGChJh",
            "Y3RpdmVfY29udHJvbGxlcnMYGSADKA4yKi5hcG9sbG8uY29udHJvbC5Db250",
            "cm9sQ29uZi5Db250cm9sbGVyVHlwZRInCh9tYXhfc3RlZXJpbmdfcGVyY2Vu",
            "dGFnZV9hbGxvd2VkGBogASgFEh8KF21heF9zdGF0dXNfaW50ZXJ2YWxfc2Vj",
            "GBsgASgBEj4KE2xhdF9jb250cm9sbGVyX2NvbmYYHCABKAsyIS5hcG9sbG8u",
            "Y29udHJvbC5MYXRDb250cm9sbGVyQ29uZhI+ChNsb25fY29udHJvbGxlcl9j",
            "b25mGB0gASgLMiEuYXBvbGxvLmNvbnRyb2wuTG9uQ29udHJvbGxlckNvbmYS",
            "GQoRdHJhamVjdG9yeV9wZXJpb2QYHiABKAESFgoOY2hhc3Npc19wZXJpb2QY",
            "HyABKAESGwoTbG9jYWxpemF0aW9uX3BlcmlvZBggIAEoARIgChhtaW5pbXVt",
            "X3NwZWVkX3Jlc29sdXRpb24YISABKAESPgoTbXBjX2NvbnRyb2xsZXJfY29u",
            "ZhgiIAEoCzIhLmFwb2xsby5jb250cm9sLk1QQ0NvbnRyb2xsZXJDb25mEhsK",
            "E3F1ZXJ5X3JlbGF0aXZlX3RpbWUYIyABKAESIAoYbWluaW11bV9zcGVlZF9w",
            "cm90ZWN0aW9uGCQgASgBIkwKDkNvbnRyb2xsZXJUeXBlEhIKDkxBVF9DT05U",
            "Uk9MTEVSEAASEgoOTE9OX0NPTlRST0xMRVIQARISCg5NUENfQ09OVFJPTExF",
            "UhACYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Apollo.Canbus.ChassisReflection.Descriptor, global::Apollo.Control.PadMsgReflection.Descriptor, global::Apollo.Control.LatControllerConfReflection.Descriptor, global::Apollo.Control.LonControllerConfReflection.Descriptor, global::Apollo.Control.MpcControllerConfReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Control.ControlConf), global::Apollo.Control.ControlConf.Parser, new[]{ "ControlTestDuration", "EnableCsvDebug", "EnableSpeedStationPreview", "IsControlTestMode", "UsePreviewSpeedForTable", "EnableInputTimestampCheck", "MaxLocalizationMissNum", "MaxChassisMissNum", "MaxPlanningMissNum", "MaxAccelerationWhenStopped", "SteerAngleRate", "EnableGainScheduler", "SetSteerLimit", "EnableSlopeOffset", "LockSteerSpeed", "EnableNavigationModeErrorFilter", "EnableNavigationModePositionUpdate", "EnablePersistentEstop", "ControlPeriod", "MaxPlanningIntervalSec", "MaxPlanningDelayThreshold", "DrivingMode", "Action", "SoftEstopBrake", "ActiveControllers", "MaxSteeringPercentageAllowed", "MaxStatusIntervalSec", "LatControllerConf", "LonControllerConf", "TrajectoryPeriod", "ChassisPeriod", "LocalizationPeriod", "MinimumSpeedResolution", "MpcControllerConf", "QueryRelativeTime", "MinimumSpeedProtection" }, null, new[]{ typeof(global::Apollo.Control.ControlConf.Types.ControllerType) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class ControlConf : pb::IMessage<ControlConf> {
    private static readonly pb::MessageParser<ControlConf> _parser = new pb::MessageParser<ControlConf>(() => new ControlConf());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControlConf> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Control.ControlConfReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControlConf() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControlConf(ControlConf other) : this() {
      controlTestDuration_ = other.controlTestDuration_;
      enableCsvDebug_ = other.enableCsvDebug_;
      enableSpeedStationPreview_ = other.enableSpeedStationPreview_;
      isControlTestMode_ = other.isControlTestMode_;
      usePreviewSpeedForTable_ = other.usePreviewSpeedForTable_;
      enableInputTimestampCheck_ = other.enableInputTimestampCheck_;
      maxLocalizationMissNum_ = other.maxLocalizationMissNum_;
      maxChassisMissNum_ = other.maxChassisMissNum_;
      maxPlanningMissNum_ = other.maxPlanningMissNum_;
      maxAccelerationWhenStopped_ = other.maxAccelerationWhenStopped_;
      steerAngleRate_ = other.steerAngleRate_;
      enableGainScheduler_ = other.enableGainScheduler_;
      setSteerLimit_ = other.setSteerLimit_;
      enableSlopeOffset_ = other.enableSlopeOffset_;
      lockSteerSpeed_ = other.lockSteerSpeed_;
      enableNavigationModeErrorFilter_ = other.enableNavigationModeErrorFilter_;
      enableNavigationModePositionUpdate_ = other.enableNavigationModePositionUpdate_;
      enablePersistentEstop_ = other.enablePersistentEstop_;
      controlPeriod_ = other.controlPeriod_;
      maxPlanningIntervalSec_ = other.maxPlanningIntervalSec_;
      maxPlanningDelayThreshold_ = other.maxPlanningDelayThreshold_;
      drivingMode_ = other.drivingMode_;
      action_ = other.action_;
      softEstopBrake_ = other.softEstopBrake_;
      activeControllers_ = other.activeControllers_.Clone();
      maxSteeringPercentageAllowed_ = other.maxSteeringPercentageAllowed_;
      maxStatusIntervalSec_ = other.maxStatusIntervalSec_;
      LatControllerConf = other.latControllerConf_ != null ? other.LatControllerConf.Clone() : null;
      LonControllerConf = other.lonControllerConf_ != null ? other.LonControllerConf.Clone() : null;
      trajectoryPeriod_ = other.trajectoryPeriod_;
      chassisPeriod_ = other.chassisPeriod_;
      localizationPeriod_ = other.localizationPeriod_;
      minimumSpeedResolution_ = other.minimumSpeedResolution_;
      MpcControllerConf = other.mpcControllerConf_ != null ? other.MpcControllerConf.Clone() : null;
      queryRelativeTime_ = other.queryRelativeTime_;
      minimumSpeedProtection_ = other.minimumSpeedProtection_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControlConf Clone() {
      return new ControlConf(this);
    }

    /// <summary>Field number for the "control_test_duration" field.</summary>
    public const int ControlTestDurationFieldNumber = 1;
    private double controlTestDuration_;
    /// <summary>
    /// configs from gflags
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ControlTestDuration {
      get { return controlTestDuration_; }
      set {
        controlTestDuration_ = value;
      }
    }

    /// <summary>Field number for the "enable_csv_debug" field.</summary>
    public const int EnableCsvDebugFieldNumber = 2;
    private bool enableCsvDebug_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableCsvDebug {
      get { return enableCsvDebug_; }
      set {
        enableCsvDebug_ = value;
      }
    }

    /// <summary>Field number for the "enable_speed_station_preview" field.</summary>
    public const int EnableSpeedStationPreviewFieldNumber = 3;
    private bool enableSpeedStationPreview_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableSpeedStationPreview {
      get { return enableSpeedStationPreview_; }
      set {
        enableSpeedStationPreview_ = value;
      }
    }

    /// <summary>Field number for the "is_control_test_mode" field.</summary>
    public const int IsControlTestModeFieldNumber = 4;
    private bool isControlTestMode_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsControlTestMode {
      get { return isControlTestMode_; }
      set {
        isControlTestMode_ = value;
      }
    }

    /// <summary>Field number for the "use_preview_speed_for_table" field.</summary>
    public const int UsePreviewSpeedForTableFieldNumber = 5;
    private bool usePreviewSpeedForTable_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UsePreviewSpeedForTable {
      get { return usePreviewSpeedForTable_; }
      set {
        usePreviewSpeedForTable_ = value;
      }
    }

    /// <summary>Field number for the "enable_input_timestamp_check" field.</summary>
    public const int EnableInputTimestampCheckFieldNumber = 6;
    private bool enableInputTimestampCheck_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableInputTimestampCheck {
      get { return enableInputTimestampCheck_; }
      set {
        enableInputTimestampCheck_ = value;
      }
    }

    /// <summary>Field number for the "max_localization_miss_num" field.</summary>
    public const int MaxLocalizationMissNumFieldNumber = 7;
    private int maxLocalizationMissNum_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxLocalizationMissNum {
      get { return maxLocalizationMissNum_; }
      set {
        maxLocalizationMissNum_ = value;
      }
    }

    /// <summary>Field number for the "max_chassis_miss_num" field.</summary>
    public const int MaxChassisMissNumFieldNumber = 8;
    private int maxChassisMissNum_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxChassisMissNum {
      get { return maxChassisMissNum_; }
      set {
        maxChassisMissNum_ = value;
      }
    }

    /// <summary>Field number for the "max_planning_miss_num" field.</summary>
    public const int MaxPlanningMissNumFieldNumber = 9;
    private int maxPlanningMissNum_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxPlanningMissNum {
      get { return maxPlanningMissNum_; }
      set {
        maxPlanningMissNum_ = value;
      }
    }

    /// <summary>Field number for the "max_acceleration_when_stopped" field.</summary>
    public const int MaxAccelerationWhenStoppedFieldNumber = 10;
    private double maxAccelerationWhenStopped_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxAccelerationWhenStopped {
      get { return maxAccelerationWhenStopped_; }
      set {
        maxAccelerationWhenStopped_ = value;
      }
    }

    /// <summary>Field number for the "steer_angle_rate" field.</summary>
    public const int SteerAngleRateFieldNumber = 11;
    private double steerAngleRate_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SteerAngleRate {
      get { return steerAngleRate_; }
      set {
        steerAngleRate_ = value;
      }
    }

    /// <summary>Field number for the "enable_gain_scheduler" field.</summary>
    public const int EnableGainSchedulerFieldNumber = 12;
    private bool enableGainScheduler_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableGainScheduler {
      get { return enableGainScheduler_; }
      set {
        enableGainScheduler_ = value;
      }
    }

    /// <summary>Field number for the "set_steer_limit" field.</summary>
    public const int SetSteerLimitFieldNumber = 13;
    private bool setSteerLimit_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SetSteerLimit {
      get { return setSteerLimit_; }
      set {
        setSteerLimit_ = value;
      }
    }

    /// <summary>Field number for the "enable_slope_offset" field.</summary>
    public const int EnableSlopeOffsetFieldNumber = 14;
    private bool enableSlopeOffset_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableSlopeOffset {
      get { return enableSlopeOffset_; }
      set {
        enableSlopeOffset_ = value;
      }
    }

    /// <summary>Field number for the "lock_steer_speed" field.</summary>
    public const int LockSteerSpeedFieldNumber = 15;
    private double lockSteerSpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double LockSteerSpeed {
      get { return lockSteerSpeed_; }
      set {
        lockSteerSpeed_ = value;
      }
    }

    /// <summary>Field number for the "enable_navigation_mode_error_filter" field.</summary>
    public const int EnableNavigationModeErrorFilterFieldNumber = 16;
    private bool enableNavigationModeErrorFilter_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableNavigationModeErrorFilter {
      get { return enableNavigationModeErrorFilter_; }
      set {
        enableNavigationModeErrorFilter_ = value;
      }
    }

    /// <summary>Field number for the "enable_navigation_mode_position_update" field.</summary>
    public const int EnableNavigationModePositionUpdateFieldNumber = 17;
    private bool enableNavigationModePositionUpdate_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableNavigationModePositionUpdate {
      get { return enableNavigationModePositionUpdate_; }
      set {
        enableNavigationModePositionUpdate_ = value;
      }
    }

    /// <summary>Field number for the "enable_persistent_estop" field.</summary>
    public const int EnablePersistentEstopFieldNumber = 18;
    private bool enablePersistentEstop_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnablePersistentEstop {
      get { return enablePersistentEstop_; }
      set {
        enablePersistentEstop_ = value;
      }
    }

    /// <summary>Field number for the "control_period" field.</summary>
    public const int ControlPeriodFieldNumber = 19;
    private double controlPeriod_;
    /// <summary>
    /// original config
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ControlPeriod {
      get { return controlPeriod_; }
      set {
        controlPeriod_ = value;
      }
    }

    /// <summary>Field number for the "max_planning_interval_sec" field.</summary>
    public const int MaxPlanningIntervalSecFieldNumber = 20;
    private double maxPlanningIntervalSec_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxPlanningIntervalSec {
      get { return maxPlanningIntervalSec_; }
      set {
        maxPlanningIntervalSec_ = value;
      }
    }

    /// <summary>Field number for the "max_planning_delay_threshold" field.</summary>
    public const int MaxPlanningDelayThresholdFieldNumber = 21;
    private double maxPlanningDelayThreshold_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxPlanningDelayThreshold {
      get { return maxPlanningDelayThreshold_; }
      set {
        maxPlanningDelayThreshold_ = value;
      }
    }

    /// <summary>Field number for the "driving_mode" field.</summary>
    public const int DrivingModeFieldNumber = 22;
    private global::Apollo.Canbus.Chassis.Types.DrivingMode drivingMode_ = 0;
    /// <summary>
    /// 0 - manual; 1 - auto_drive; 2 - speed_only; 3 - steer_only
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Canbus.Chassis.Types.DrivingMode DrivingMode {
      get { return drivingMode_; }
      set {
        drivingMode_ = value;
      }
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 23;
    private global::Apollo.Control.DrivingAction action_ = 0;
    /// <summary>
    /// 0: stop, at first should stop, then receive pad msg to start
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Control.DrivingAction Action {
      get { return action_; }
      set {
        action_ = value;
      }
    }

    /// <summary>Field number for the "soft_estop_brake" field.</summary>
    public const int SoftEstopBrakeFieldNumber = 24;
    private double softEstopBrake_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SoftEstopBrake {
      get { return softEstopBrake_; }
      set {
        softEstopBrake_ = value;
      }
    }

    /// <summary>Field number for the "active_controllers" field.</summary>
    public const int ActiveControllersFieldNumber = 25;
    private static readonly pb::FieldCodec<global::Apollo.Control.ControlConf.Types.ControllerType> _repeated_activeControllers_codec
        = pb::FieldCodec.ForEnum(202, x => (int) x, x => (global::Apollo.Control.ControlConf.Types.ControllerType) x);
    private readonly pbc::RepeatedField<global::Apollo.Control.ControlConf.Types.ControllerType> activeControllers_ = new pbc::RepeatedField<global::Apollo.Control.ControlConf.Types.ControllerType>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Control.ControlConf.Types.ControllerType> ActiveControllers {
      get { return activeControllers_; }
    }

    /// <summary>Field number for the "max_steering_percentage_allowed" field.</summary>
    public const int MaxSteeringPercentageAllowedFieldNumber = 26;
    private int maxSteeringPercentageAllowed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxSteeringPercentageAllowed {
      get { return maxSteeringPercentageAllowed_; }
      set {
        maxSteeringPercentageAllowed_ = value;
      }
    }

    /// <summary>Field number for the "max_status_interval_sec" field.</summary>
    public const int MaxStatusIntervalSecFieldNumber = 27;
    private double maxStatusIntervalSec_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStatusIntervalSec {
      get { return maxStatusIntervalSec_; }
      set {
        maxStatusIntervalSec_ = value;
      }
    }

    /// <summary>Field number for the "lat_controller_conf" field.</summary>
    public const int LatControllerConfFieldNumber = 28;
    private global::Apollo.Control.LatControllerConf latControllerConf_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Control.LatControllerConf LatControllerConf {
      get { return latControllerConf_; }
      set {
        latControllerConf_ = value;
      }
    }

    /// <summary>Field number for the "lon_controller_conf" field.</summary>
    public const int LonControllerConfFieldNumber = 29;
    private global::Apollo.Control.LonControllerConf lonControllerConf_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Control.LonControllerConf LonControllerConf {
      get { return lonControllerConf_; }
      set {
        lonControllerConf_ = value;
      }
    }

    /// <summary>Field number for the "trajectory_period" field.</summary>
    public const int TrajectoryPeriodFieldNumber = 30;
    private double trajectoryPeriod_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TrajectoryPeriod {
      get { return trajectoryPeriod_; }
      set {
        trajectoryPeriod_ = value;
      }
    }

    /// <summary>Field number for the "chassis_period" field.</summary>
    public const int ChassisPeriodFieldNumber = 31;
    private double chassisPeriod_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ChassisPeriod {
      get { return chassisPeriod_; }
      set {
        chassisPeriod_ = value;
      }
    }

    /// <summary>Field number for the "localization_period" field.</summary>
    public const int LocalizationPeriodFieldNumber = 32;
    private double localizationPeriod_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double LocalizationPeriod {
      get { return localizationPeriod_; }
      set {
        localizationPeriod_ = value;
      }
    }

    /// <summary>Field number for the "minimum_speed_resolution" field.</summary>
    public const int MinimumSpeedResolutionFieldNumber = 33;
    private double minimumSpeedResolution_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinimumSpeedResolution {
      get { return minimumSpeedResolution_; }
      set {
        minimumSpeedResolution_ = value;
      }
    }

    /// <summary>Field number for the "mpc_controller_conf" field.</summary>
    public const int MpcControllerConfFieldNumber = 34;
    private global::Apollo.Control.MPCControllerConf mpcControllerConf_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Control.MPCControllerConf MpcControllerConf {
      get { return mpcControllerConf_; }
      set {
        mpcControllerConf_ = value;
      }
    }

    /// <summary>Field number for the "query_relative_time" field.</summary>
    public const int QueryRelativeTimeFieldNumber = 35;
    private double queryRelativeTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double QueryRelativeTime {
      get { return queryRelativeTime_; }
      set {
        queryRelativeTime_ = value;
      }
    }

    /// <summary>Field number for the "minimum_speed_protection" field.</summary>
    public const int MinimumSpeedProtectionFieldNumber = 36;
    private double minimumSpeedProtection_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinimumSpeedProtection {
      get { return minimumSpeedProtection_; }
      set {
        minimumSpeedProtection_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControlConf);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControlConf other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ControlTestDuration != other.ControlTestDuration) return false;
      if (EnableCsvDebug != other.EnableCsvDebug) return false;
      if (EnableSpeedStationPreview != other.EnableSpeedStationPreview) return false;
      if (IsControlTestMode != other.IsControlTestMode) return false;
      if (UsePreviewSpeedForTable != other.UsePreviewSpeedForTable) return false;
      if (EnableInputTimestampCheck != other.EnableInputTimestampCheck) return false;
      if (MaxLocalizationMissNum != other.MaxLocalizationMissNum) return false;
      if (MaxChassisMissNum != other.MaxChassisMissNum) return false;
      if (MaxPlanningMissNum != other.MaxPlanningMissNum) return false;
      if (MaxAccelerationWhenStopped != other.MaxAccelerationWhenStopped) return false;
      if (SteerAngleRate != other.SteerAngleRate) return false;
      if (EnableGainScheduler != other.EnableGainScheduler) return false;
      if (SetSteerLimit != other.SetSteerLimit) return false;
      if (EnableSlopeOffset != other.EnableSlopeOffset) return false;
      if (LockSteerSpeed != other.LockSteerSpeed) return false;
      if (EnableNavigationModeErrorFilter != other.EnableNavigationModeErrorFilter) return false;
      if (EnableNavigationModePositionUpdate != other.EnableNavigationModePositionUpdate) return false;
      if (EnablePersistentEstop != other.EnablePersistentEstop) return false;
      if (ControlPeriod != other.ControlPeriod) return false;
      if (MaxPlanningIntervalSec != other.MaxPlanningIntervalSec) return false;
      if (MaxPlanningDelayThreshold != other.MaxPlanningDelayThreshold) return false;
      if (DrivingMode != other.DrivingMode) return false;
      if (Action != other.Action) return false;
      if (SoftEstopBrake != other.SoftEstopBrake) return false;
      if(!activeControllers_.Equals(other.activeControllers_)) return false;
      if (MaxSteeringPercentageAllowed != other.MaxSteeringPercentageAllowed) return false;
      if (MaxStatusIntervalSec != other.MaxStatusIntervalSec) return false;
      if (!object.Equals(LatControllerConf, other.LatControllerConf)) return false;
      if (!object.Equals(LonControllerConf, other.LonControllerConf)) return false;
      if (TrajectoryPeriod != other.TrajectoryPeriod) return false;
      if (ChassisPeriod != other.ChassisPeriod) return false;
      if (LocalizationPeriod != other.LocalizationPeriod) return false;
      if (MinimumSpeedResolution != other.MinimumSpeedResolution) return false;
      if (!object.Equals(MpcControllerConf, other.MpcControllerConf)) return false;
      if (QueryRelativeTime != other.QueryRelativeTime) return false;
      if (MinimumSpeedProtection != other.MinimumSpeedProtection) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ControlTestDuration != 0D) hash ^= ControlTestDuration.GetHashCode();
      if (EnableCsvDebug != false) hash ^= EnableCsvDebug.GetHashCode();
      if (EnableSpeedStationPreview != false) hash ^= EnableSpeedStationPreview.GetHashCode();
      if (IsControlTestMode != false) hash ^= IsControlTestMode.GetHashCode();
      if (UsePreviewSpeedForTable != false) hash ^= UsePreviewSpeedForTable.GetHashCode();
      if (EnableInputTimestampCheck != false) hash ^= EnableInputTimestampCheck.GetHashCode();
      if (MaxLocalizationMissNum != 0) hash ^= MaxLocalizationMissNum.GetHashCode();
      if (MaxChassisMissNum != 0) hash ^= MaxChassisMissNum.GetHashCode();
      if (MaxPlanningMissNum != 0) hash ^= MaxPlanningMissNum.GetHashCode();
      if (MaxAccelerationWhenStopped != 0D) hash ^= MaxAccelerationWhenStopped.GetHashCode();
      if (SteerAngleRate != 0D) hash ^= SteerAngleRate.GetHashCode();
      if (EnableGainScheduler != false) hash ^= EnableGainScheduler.GetHashCode();
      if (SetSteerLimit != false) hash ^= SetSteerLimit.GetHashCode();
      if (EnableSlopeOffset != false) hash ^= EnableSlopeOffset.GetHashCode();
      if (LockSteerSpeed != 0D) hash ^= LockSteerSpeed.GetHashCode();
      if (EnableNavigationModeErrorFilter != false) hash ^= EnableNavigationModeErrorFilter.GetHashCode();
      if (EnableNavigationModePositionUpdate != false) hash ^= EnableNavigationModePositionUpdate.GetHashCode();
      if (EnablePersistentEstop != false) hash ^= EnablePersistentEstop.GetHashCode();
      if (ControlPeriod != 0D) hash ^= ControlPeriod.GetHashCode();
      if (MaxPlanningIntervalSec != 0D) hash ^= MaxPlanningIntervalSec.GetHashCode();
      if (MaxPlanningDelayThreshold != 0D) hash ^= MaxPlanningDelayThreshold.GetHashCode();
      if (DrivingMode != 0) hash ^= DrivingMode.GetHashCode();
      if (Action != 0) hash ^= Action.GetHashCode();
      if (SoftEstopBrake != 0D) hash ^= SoftEstopBrake.GetHashCode();
      hash ^= activeControllers_.GetHashCode();
      if (MaxSteeringPercentageAllowed != 0) hash ^= MaxSteeringPercentageAllowed.GetHashCode();
      if (MaxStatusIntervalSec != 0D) hash ^= MaxStatusIntervalSec.GetHashCode();
      if (latControllerConf_ != null) hash ^= LatControllerConf.GetHashCode();
      if (lonControllerConf_ != null) hash ^= LonControllerConf.GetHashCode();
      if (TrajectoryPeriod != 0D) hash ^= TrajectoryPeriod.GetHashCode();
      if (ChassisPeriod != 0D) hash ^= ChassisPeriod.GetHashCode();
      if (LocalizationPeriod != 0D) hash ^= LocalizationPeriod.GetHashCode();
      if (MinimumSpeedResolution != 0D) hash ^= MinimumSpeedResolution.GetHashCode();
      if (mpcControllerConf_ != null) hash ^= MpcControllerConf.GetHashCode();
      if (QueryRelativeTime != 0D) hash ^= QueryRelativeTime.GetHashCode();
      if (MinimumSpeedProtection != 0D) hash ^= MinimumSpeedProtection.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ControlTestDuration != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(ControlTestDuration);
      }
      if (EnableCsvDebug != false) {
        output.WriteRawTag(16);
        output.WriteBool(EnableCsvDebug);
      }
      if (EnableSpeedStationPreview != false) {
        output.WriteRawTag(24);
        output.WriteBool(EnableSpeedStationPreview);
      }
      if (IsControlTestMode != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsControlTestMode);
      }
      if (UsePreviewSpeedForTable != false) {
        output.WriteRawTag(40);
        output.WriteBool(UsePreviewSpeedForTable);
      }
      if (EnableInputTimestampCheck != false) {
        output.WriteRawTag(48);
        output.WriteBool(EnableInputTimestampCheck);
      }
      if (MaxLocalizationMissNum != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(MaxLocalizationMissNum);
      }
      if (MaxChassisMissNum != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(MaxChassisMissNum);
      }
      if (MaxPlanningMissNum != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(MaxPlanningMissNum);
      }
      if (MaxAccelerationWhenStopped != 0D) {
        output.WriteRawTag(81);
        output.WriteDouble(MaxAccelerationWhenStopped);
      }
      if (SteerAngleRate != 0D) {
        output.WriteRawTag(89);
        output.WriteDouble(SteerAngleRate);
      }
      if (EnableGainScheduler != false) {
        output.WriteRawTag(96);
        output.WriteBool(EnableGainScheduler);
      }
      if (SetSteerLimit != false) {
        output.WriteRawTag(104);
        output.WriteBool(SetSteerLimit);
      }
      if (EnableSlopeOffset != false) {
        output.WriteRawTag(112);
        output.WriteBool(EnableSlopeOffset);
      }
      if (LockSteerSpeed != 0D) {
        output.WriteRawTag(121);
        output.WriteDouble(LockSteerSpeed);
      }
      if (EnableNavigationModeErrorFilter != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(EnableNavigationModeErrorFilter);
      }
      if (EnableNavigationModePositionUpdate != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(EnableNavigationModePositionUpdate);
      }
      if (EnablePersistentEstop != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(EnablePersistentEstop);
      }
      if (ControlPeriod != 0D) {
        output.WriteRawTag(153, 1);
        output.WriteDouble(ControlPeriod);
      }
      if (MaxPlanningIntervalSec != 0D) {
        output.WriteRawTag(161, 1);
        output.WriteDouble(MaxPlanningIntervalSec);
      }
      if (MaxPlanningDelayThreshold != 0D) {
        output.WriteRawTag(169, 1);
        output.WriteDouble(MaxPlanningDelayThreshold);
      }
      if (DrivingMode != 0) {
        output.WriteRawTag(176, 1);
        output.WriteEnum((int) DrivingMode);
      }
      if (Action != 0) {
        output.WriteRawTag(184, 1);
        output.WriteEnum((int) Action);
      }
      if (SoftEstopBrake != 0D) {
        output.WriteRawTag(193, 1);
        output.WriteDouble(SoftEstopBrake);
      }
      activeControllers_.WriteTo(output, _repeated_activeControllers_codec);
      if (MaxSteeringPercentageAllowed != 0) {
        output.WriteRawTag(208, 1);
        output.WriteInt32(MaxSteeringPercentageAllowed);
      }
      if (MaxStatusIntervalSec != 0D) {
        output.WriteRawTag(217, 1);
        output.WriteDouble(MaxStatusIntervalSec);
      }
      if (latControllerConf_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(LatControllerConf);
      }
      if (lonControllerConf_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(LonControllerConf);
      }
      if (TrajectoryPeriod != 0D) {
        output.WriteRawTag(241, 1);
        output.WriteDouble(TrajectoryPeriod);
      }
      if (ChassisPeriod != 0D) {
        output.WriteRawTag(249, 1);
        output.WriteDouble(ChassisPeriod);
      }
      if (LocalizationPeriod != 0D) {
        output.WriteRawTag(129, 2);
        output.WriteDouble(LocalizationPeriod);
      }
      if (MinimumSpeedResolution != 0D) {
        output.WriteRawTag(137, 2);
        output.WriteDouble(MinimumSpeedResolution);
      }
      if (mpcControllerConf_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(MpcControllerConf);
      }
      if (QueryRelativeTime != 0D) {
        output.WriteRawTag(153, 2);
        output.WriteDouble(QueryRelativeTime);
      }
      if (MinimumSpeedProtection != 0D) {
        output.WriteRawTag(161, 2);
        output.WriteDouble(MinimumSpeedProtection);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ControlTestDuration != 0D) {
        size += 1 + 8;
      }
      if (EnableCsvDebug != false) {
        size += 1 + 1;
      }
      if (EnableSpeedStationPreview != false) {
        size += 1 + 1;
      }
      if (IsControlTestMode != false) {
        size += 1 + 1;
      }
      if (UsePreviewSpeedForTable != false) {
        size += 1 + 1;
      }
      if (EnableInputTimestampCheck != false) {
        size += 1 + 1;
      }
      if (MaxLocalizationMissNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxLocalizationMissNum);
      }
      if (MaxChassisMissNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxChassisMissNum);
      }
      if (MaxPlanningMissNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxPlanningMissNum);
      }
      if (MaxAccelerationWhenStopped != 0D) {
        size += 1 + 8;
      }
      if (SteerAngleRate != 0D) {
        size += 1 + 8;
      }
      if (EnableGainScheduler != false) {
        size += 1 + 1;
      }
      if (SetSteerLimit != false) {
        size += 1 + 1;
      }
      if (EnableSlopeOffset != false) {
        size += 1 + 1;
      }
      if (LockSteerSpeed != 0D) {
        size += 1 + 8;
      }
      if (EnableNavigationModeErrorFilter != false) {
        size += 2 + 1;
      }
      if (EnableNavigationModePositionUpdate != false) {
        size += 2 + 1;
      }
      if (EnablePersistentEstop != false) {
        size += 2 + 1;
      }
      if (ControlPeriod != 0D) {
        size += 2 + 8;
      }
      if (MaxPlanningIntervalSec != 0D) {
        size += 2 + 8;
      }
      if (MaxPlanningDelayThreshold != 0D) {
        size += 2 + 8;
      }
      if (DrivingMode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DrivingMode);
      }
      if (Action != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Action);
      }
      if (SoftEstopBrake != 0D) {
        size += 2 + 8;
      }
      size += activeControllers_.CalculateSize(_repeated_activeControllers_codec);
      if (MaxSteeringPercentageAllowed != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxSteeringPercentageAllowed);
      }
      if (MaxStatusIntervalSec != 0D) {
        size += 2 + 8;
      }
      if (latControllerConf_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LatControllerConf);
      }
      if (lonControllerConf_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LonControllerConf);
      }
      if (TrajectoryPeriod != 0D) {
        size += 2 + 8;
      }
      if (ChassisPeriod != 0D) {
        size += 2 + 8;
      }
      if (LocalizationPeriod != 0D) {
        size += 2 + 8;
      }
      if (MinimumSpeedResolution != 0D) {
        size += 2 + 8;
      }
      if (mpcControllerConf_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MpcControllerConf);
      }
      if (QueryRelativeTime != 0D) {
        size += 2 + 8;
      }
      if (MinimumSpeedProtection != 0D) {
        size += 2 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControlConf other) {
      if (other == null) {
        return;
      }
      if (other.ControlTestDuration != 0D) {
        ControlTestDuration = other.ControlTestDuration;
      }
      if (other.EnableCsvDebug != false) {
        EnableCsvDebug = other.EnableCsvDebug;
      }
      if (other.EnableSpeedStationPreview != false) {
        EnableSpeedStationPreview = other.EnableSpeedStationPreview;
      }
      if (other.IsControlTestMode != false) {
        IsControlTestMode = other.IsControlTestMode;
      }
      if (other.UsePreviewSpeedForTable != false) {
        UsePreviewSpeedForTable = other.UsePreviewSpeedForTable;
      }
      if (other.EnableInputTimestampCheck != false) {
        EnableInputTimestampCheck = other.EnableInputTimestampCheck;
      }
      if (other.MaxLocalizationMissNum != 0) {
        MaxLocalizationMissNum = other.MaxLocalizationMissNum;
      }
      if (other.MaxChassisMissNum != 0) {
        MaxChassisMissNum = other.MaxChassisMissNum;
      }
      if (other.MaxPlanningMissNum != 0) {
        MaxPlanningMissNum = other.MaxPlanningMissNum;
      }
      if (other.MaxAccelerationWhenStopped != 0D) {
        MaxAccelerationWhenStopped = other.MaxAccelerationWhenStopped;
      }
      if (other.SteerAngleRate != 0D) {
        SteerAngleRate = other.SteerAngleRate;
      }
      if (other.EnableGainScheduler != false) {
        EnableGainScheduler = other.EnableGainScheduler;
      }
      if (other.SetSteerLimit != false) {
        SetSteerLimit = other.SetSteerLimit;
      }
      if (other.EnableSlopeOffset != false) {
        EnableSlopeOffset = other.EnableSlopeOffset;
      }
      if (other.LockSteerSpeed != 0D) {
        LockSteerSpeed = other.LockSteerSpeed;
      }
      if (other.EnableNavigationModeErrorFilter != false) {
        EnableNavigationModeErrorFilter = other.EnableNavigationModeErrorFilter;
      }
      if (other.EnableNavigationModePositionUpdate != false) {
        EnableNavigationModePositionUpdate = other.EnableNavigationModePositionUpdate;
      }
      if (other.EnablePersistentEstop != false) {
        EnablePersistentEstop = other.EnablePersistentEstop;
      }
      if (other.ControlPeriod != 0D) {
        ControlPeriod = other.ControlPeriod;
      }
      if (other.MaxPlanningIntervalSec != 0D) {
        MaxPlanningIntervalSec = other.MaxPlanningIntervalSec;
      }
      if (other.MaxPlanningDelayThreshold != 0D) {
        MaxPlanningDelayThreshold = other.MaxPlanningDelayThreshold;
      }
      if (other.DrivingMode != 0) {
        DrivingMode = other.DrivingMode;
      }
      if (other.Action != 0) {
        Action = other.Action;
      }
      if (other.SoftEstopBrake != 0D) {
        SoftEstopBrake = other.SoftEstopBrake;
      }
      activeControllers_.Add(other.activeControllers_);
      if (other.MaxSteeringPercentageAllowed != 0) {
        MaxSteeringPercentageAllowed = other.MaxSteeringPercentageAllowed;
      }
      if (other.MaxStatusIntervalSec != 0D) {
        MaxStatusIntervalSec = other.MaxStatusIntervalSec;
      }
      if (other.latControllerConf_ != null) {
        if (latControllerConf_ == null) {
          latControllerConf_ = new global::Apollo.Control.LatControllerConf();
        }
        LatControllerConf.MergeFrom(other.LatControllerConf);
      }
      if (other.lonControllerConf_ != null) {
        if (lonControllerConf_ == null) {
          lonControllerConf_ = new global::Apollo.Control.LonControllerConf();
        }
        LonControllerConf.MergeFrom(other.LonControllerConf);
      }
      if (other.TrajectoryPeriod != 0D) {
        TrajectoryPeriod = other.TrajectoryPeriod;
      }
      if (other.ChassisPeriod != 0D) {
        ChassisPeriod = other.ChassisPeriod;
      }
      if (other.LocalizationPeriod != 0D) {
        LocalizationPeriod = other.LocalizationPeriod;
      }
      if (other.MinimumSpeedResolution != 0D) {
        MinimumSpeedResolution = other.MinimumSpeedResolution;
      }
      if (other.mpcControllerConf_ != null) {
        if (mpcControllerConf_ == null) {
          mpcControllerConf_ = new global::Apollo.Control.MPCControllerConf();
        }
        MpcControllerConf.MergeFrom(other.MpcControllerConf);
      }
      if (other.QueryRelativeTime != 0D) {
        QueryRelativeTime = other.QueryRelativeTime;
      }
      if (other.MinimumSpeedProtection != 0D) {
        MinimumSpeedProtection = other.MinimumSpeedProtection;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            ControlTestDuration = input.ReadDouble();
            break;
          }
          case 16: {
            EnableCsvDebug = input.ReadBool();
            break;
          }
          case 24: {
            EnableSpeedStationPreview = input.ReadBool();
            break;
          }
          case 32: {
            IsControlTestMode = input.ReadBool();
            break;
          }
          case 40: {
            UsePreviewSpeedForTable = input.ReadBool();
            break;
          }
          case 48: {
            EnableInputTimestampCheck = input.ReadBool();
            break;
          }
          case 56: {
            MaxLocalizationMissNum = input.ReadInt32();
            break;
          }
          case 64: {
            MaxChassisMissNum = input.ReadInt32();
            break;
          }
          case 72: {
            MaxPlanningMissNum = input.ReadInt32();
            break;
          }
          case 81: {
            MaxAccelerationWhenStopped = input.ReadDouble();
            break;
          }
          case 89: {
            SteerAngleRate = input.ReadDouble();
            break;
          }
          case 96: {
            EnableGainScheduler = input.ReadBool();
            break;
          }
          case 104: {
            SetSteerLimit = input.ReadBool();
            break;
          }
          case 112: {
            EnableSlopeOffset = input.ReadBool();
            break;
          }
          case 121: {
            LockSteerSpeed = input.ReadDouble();
            break;
          }
          case 128: {
            EnableNavigationModeErrorFilter = input.ReadBool();
            break;
          }
          case 136: {
            EnableNavigationModePositionUpdate = input.ReadBool();
            break;
          }
          case 144: {
            EnablePersistentEstop = input.ReadBool();
            break;
          }
          case 153: {
            ControlPeriod = input.ReadDouble();
            break;
          }
          case 161: {
            MaxPlanningIntervalSec = input.ReadDouble();
            break;
          }
          case 169: {
            MaxPlanningDelayThreshold = input.ReadDouble();
            break;
          }
          case 176: {
            drivingMode_ = (global::Apollo.Canbus.Chassis.Types.DrivingMode) input.ReadEnum();
            break;
          }
          case 184: {
            action_ = (global::Apollo.Control.DrivingAction) input.ReadEnum();
            break;
          }
          case 193: {
            SoftEstopBrake = input.ReadDouble();
            break;
          }
          case 202:
          case 200: {
            activeControllers_.AddEntriesFrom(input, _repeated_activeControllers_codec);
            break;
          }
          case 208: {
            MaxSteeringPercentageAllowed = input.ReadInt32();
            break;
          }
          case 217: {
            MaxStatusIntervalSec = input.ReadDouble();
            break;
          }
          case 226: {
            if (latControllerConf_ == null) {
              latControllerConf_ = new global::Apollo.Control.LatControllerConf();
            }
            input.ReadMessage(latControllerConf_);
            break;
          }
          case 234: {
            if (lonControllerConf_ == null) {
              lonControllerConf_ = new global::Apollo.Control.LonControllerConf();
            }
            input.ReadMessage(lonControllerConf_);
            break;
          }
          case 241: {
            TrajectoryPeriod = input.ReadDouble();
            break;
          }
          case 249: {
            ChassisPeriod = input.ReadDouble();
            break;
          }
          case 257: {
            LocalizationPeriod = input.ReadDouble();
            break;
          }
          case 265: {
            MinimumSpeedResolution = input.ReadDouble();
            break;
          }
          case 274: {
            if (mpcControllerConf_ == null) {
              mpcControllerConf_ = new global::Apollo.Control.MPCControllerConf();
            }
            input.ReadMessage(mpcControllerConf_);
            break;
          }
          case 281: {
            QueryRelativeTime = input.ReadDouble();
            break;
          }
          case 289: {
            MinimumSpeedProtection = input.ReadDouble();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ControlConf message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum ControllerType {
        [pbr::OriginalName("LAT_CONTROLLER")] LatController = 0,
        [pbr::OriginalName("LON_CONTROLLER")] LonController = 1,
        [pbr::OriginalName("MPC_CONTROLLER")] MpcController = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
