// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/traffic_rule_config.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Apollo.Planning {

  /// <summary>Holder for reflection information generated from modules/planning/proto/traffic_rule_config.proto</summary>
  public static partial class TrafficRuleConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for modules/planning/proto/traffic_rule_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TrafficRuleConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjBtb2R1bGVzL3BsYW5uaW5nL3Byb3RvL3RyYWZmaWNfcnVsZV9jb25maWcu",
            "cHJvdG8SD2Fwb2xsby5wbGFubmluZyI0ChVCYWNrc2lkZVZlaGljbGVDb25m",
            "aWcSGwoTYmFja3NpZGVfbGFuZV93aWR0aBgBIAEoASKcAQoQQ2hhbmdlTGFu",
            "ZUNvbmZpZxIdChVtaW5fb3ZlcnRha2VfZGlzdGFuY2UYASABKAESGQoRbWlu",
            "X292ZXJ0YWtlX3RpbWUYAiABKAESHQoVZW5hYmxlX2d1YXJkX29ic3RhY2xl",
            "GAMgASgIEhYKDmd1YXJkX2Rpc3RhbmNlGAQgASgBEhcKD21pbl9ndWFyZF9z",
            "cGVlZBgFIAEoASLAAQoLQ3JlZXBDb25maWcSDwoHZW5hYmxlZBgBIAEoCBIj",
            "ChtjcmVlcF9kaXN0YW5jZV90b19zdG9wX2xpbmUYAiABKAESFQoNc3RvcF9k",
            "aXN0YW5jZRgDIAEoARITCgtzcGVlZF9saW1pdBgEIAEoARIfChdtYXhfdmFs",
            "aWRfc3RvcF9kaXN0YW5jZRgFIAEoARIWCg5taW5fYm91bmRhcnlfdBgGIAEo",
            "ARIWCg5taW5fYm91bmRhcnlfcxgHIAEoASKNAgoPQ3Jvc3N3YWxrQ29uZmln",
            "EhUKDXN0b3BfZGlzdGFuY2UYASABKAESHQoVbWF4X3N0b3BfZGVjZWxlcmF0",
            "aW9uGAIgASgBEhsKE21pbl9wYXNzX3NfZGlzdGFuY2UYAyABKAESFgoObWF4",
            "X3N0b3Bfc3BlZWQYBCABKAESHwoXbWF4X3ZhbGlkX3N0b3BfZGlzdGFuY2UY",
            "BSABKAESGQoRZXhwYW5kX3NfZGlzdGFuY2UYBiABKAESHgoWc3RvcF9zdHJp",
            "Y2tfbF9kaXN0YW5jZRgHIAEoARIdChVzdG9wX2xvb3NlX2xfZGlzdGFuY2UY",
            "CCABKAESFAoMc3RvcF90aW1lb3V0GAkgASgBImUKEURlc3RpbmF0aW9uQ29u",
            "ZmlnEhgKEGVuYWJsZV9wdWxsX292ZXIYASABKAgSFQoNc3RvcF9kaXN0YW5j",
            "ZRgCIAEoARIfChdwdWxsX292ZXJfcGxhbl9kaXN0YW5jZRgDIAEoASJnCg9L",
            "ZWVwQ2xlYXJDb25maWcSHgoWZW5hYmxlX2tlZXBfY2xlYXJfem9uZRgBIAEo",
            "CBIXCg9lbmFibGVfanVuY3Rpb24YAiABKAgSGwoTbWluX3Bhc3Nfc19kaXN0",
            "YW5jZRgDIAEoASKgAgoOUHVsbE92ZXJDb25maWcSFQoNc3RvcF9kaXN0YW5j",
            "ZRgBIAEoARIWCg5tYXhfc3RvcF9zcGVlZBgCIAEoARIfChdtYXhfdmFsaWRf",
            "c3RvcF9kaXN0YW5jZRgDIAEoARIdChVtYXhfc3RvcF9kZWNlbGVyYXRpb24Y",
            "BCABKAESGwoTbWluX3Bhc3Nfc19kaXN0YW5jZRgFIAEoARIaChJidWZmZXJf",
            "dG9fYm91bmRhcnkYBiABKAESFQoNcGxhbl9kaXN0YW5jZRgHIAEoARIYChBv",
            "cGVyYXRpb25fbGVuZ3RoGAggASgBEhoKEm1heF9jaGVja19kaXN0YW5jZRgJ",
            "IAEoARIZChFtYXhfZmFpbHVyZV9jb3VudBgKIAEoDSJZChZSZWZlcmVuY2VM",
            "aW5lRW5kQ29uZmlnEhUKDXN0b3BfZGlzdGFuY2UYASABKAESKAogbWluX3Jl",
            "ZmVyZW5jZV9saW5lX3JlbWFpbl9sZW5ndGgYAiABKAEiSAoPUmVyb3V0aW5n",
            "Q29uZmlnEhUKDWNvb2xkb3duX3RpbWUYASABKAESHgoWcHJlcGFyZV9yZXJv",
            "dXRpbmdfdGltZRgCIAEoASKRAgoRU2lnbmFsTGlnaHRDb25maWcSFQoNc3Rv",
            "cF9kaXN0YW5jZRgBIAEoARIdChVtYXhfc3RvcF9kZWNlbGVyYXRpb24YAiAB",
            "KAESGwoTbWluX3Bhc3Nfc19kaXN0YW5jZRgDIAEoARIsCiRtYXhfc3RvcF9k",
            "ZWFjY2VsZXJhdGlvbl95ZWxsb3dfbGlnaHQYBCABKAESHgoWc2lnbmFsX2V4",
            "cGlyZV90aW1lX3NlYxgFIAEoARIkChxtYXhfbW9uaXRvcl9mb3J3YXJkX2Rp",
            "c3RhbmNlGAYgASgBEjUKD3JpZ2hfdHVybl9jcmVlcBgHIAEoCzIcLmFwb2xs",
            "by5wbGFubmluZy5DcmVlcENvbmZpZyLNBgoRVHJhZmZpY1J1bGVDb25maWcS",
            "OgoHcnVsZV9pZBgBIAEoDjIpLmFwb2xsby5wbGFubmluZy5UcmFmZmljUnVs",
            "ZUNvbmZpZy5SdWxlSWQSDwoHZW5hYmxlZBgCIAEoCBJCChBiYWNrc2lkZV92",
            "ZWhpY2xlGAMgASgLMiYuYXBvbGxvLnBsYW5uaW5nLkJhY2tzaWRlVmVoaWNs",
            "ZUNvbmZpZ0gAEjgKC2NoYW5nZV9sYW5lGAQgASgLMiEuYXBvbGxvLnBsYW5u",
            "aW5nLkNoYW5nZUxhbmVDb25maWdIABI1Cgljcm9zc3dhbGsYBSABKAsyIC5h",
            "cG9sbG8ucGxhbm5pbmcuQ3Jvc3N3YWxrQ29uZmlnSAASOQoLZGVzdGluYXRp",
            "b24YBiABKAsyIi5hcG9sbG8ucGxhbm5pbmcuRGVzdGluYXRpb25Db25maWdI",
            "ABI2CgprZWVwX2NsZWFyGAcgASgLMiAuYXBvbGxvLnBsYW5uaW5nLktlZXBD",
            "bGVhckNvbmZpZ0gAEjQKCXB1bGxfb3ZlchgIIAEoCzIfLmFwb2xsby5wbGFu",
            "bmluZy5QdWxsT3ZlckNvbmZpZ0gAEkUKEnJlZmVyZW5jZV9saW5lX2VuZBgJ",
            "IAEoCzInLmFwb2xsby5wbGFubmluZy5SZWZlcmVuY2VMaW5lRW5kQ29uZmln",
            "SAASNQoJcmVyb3V0aW5nGAogASgLMiAuYXBvbGxvLnBsYW5uaW5nLlJlcm91",
            "dGluZ0NvbmZpZ0gAEjoKDHNpZ25hbF9saWdodBgLIAEoCzIiLmFwb2xsby5w",
            "bGFubmluZy5TaWduYWxMaWdodENvbmZpZ0gAIsgBCgZSdWxlSWQSEAoMUlVM",
            "RUlEX0RVTU1ZEAASFAoQQkFDS1NJREVfVkVISUNMRRABEg8KC0NIQU5HRV9M",
            "QU5FEAISDQoJQ1JPU1NXQUxLEAMSDwoLREVTVElOQVRJT04QBBIOCgpLRUVQ",
            "X0NMRUFSEAUSDQoJUFVMTF9PVkVSEAYSFgoSUkVGRVJFTkNFX0xJTkVfRU5E",
            "EAcSDQoJUkVST1VUSU5HEAgSEAoMU0lHTkFMX0xJR0hUEAkSDQoJU1RPUF9T",
            "SUdOEApCCAoGY29uZmlnIkgKElRyYWZmaWNSdWxlQ29uZmlncxIyCgZjb25m",
            "aWcYASADKAsyIi5hcG9sbG8ucGxhbm5pbmcuVHJhZmZpY1J1bGVDb25maWdi",
            "BnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.BacksideVehicleConfig), global::Apollo.Planning.BacksideVehicleConfig.Parser, new[]{ "BacksideLaneWidth" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.ChangeLaneConfig), global::Apollo.Planning.ChangeLaneConfig.Parser, new[]{ "MinOvertakeDistance", "MinOvertakeTime", "EnableGuardObstacle", "GuardDistance", "MinGuardSpeed" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.CreepConfig), global::Apollo.Planning.CreepConfig.Parser, new[]{ "Enabled", "CreepDistanceToStopLine", "StopDistance", "SpeedLimit", "MaxValidStopDistance", "MinBoundaryT", "MinBoundaryS" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.CrosswalkConfig), global::Apollo.Planning.CrosswalkConfig.Parser, new[]{ "StopDistance", "MaxStopDeceleration", "MinPassSDistance", "MaxStopSpeed", "MaxValidStopDistance", "ExpandSDistance", "StopStrickLDistance", "StopLooseLDistance", "StopTimeout" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.DestinationConfig), global::Apollo.Planning.DestinationConfig.Parser, new[]{ "EnablePullOver", "StopDistance", "PullOverPlanDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.KeepClearConfig), global::Apollo.Planning.KeepClearConfig.Parser, new[]{ "EnableKeepClearZone", "EnableJunction", "MinPassSDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.PullOverConfig), global::Apollo.Planning.PullOverConfig.Parser, new[]{ "StopDistance", "MaxStopSpeed", "MaxValidStopDistance", "MaxStopDeceleration", "MinPassSDistance", "BufferToBoundary", "PlanDistance", "OperationLength", "MaxCheckDistance", "MaxFailureCount" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.ReferenceLineEndConfig), global::Apollo.Planning.ReferenceLineEndConfig.Parser, new[]{ "StopDistance", "MinReferenceLineRemainLength" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.ReroutingConfig), global::Apollo.Planning.ReroutingConfig.Parser, new[]{ "CooldownTime", "PrepareReroutingTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.SignalLightConfig), global::Apollo.Planning.SignalLightConfig.Parser, new[]{ "StopDistance", "MaxStopDeceleration", "MinPassSDistance", "MaxStopDeaccelerationYellowLight", "SignalExpireTimeSec", "MaxMonitorForwardDistance", "RighTurnCreep" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.TrafficRuleConfig), global::Apollo.Planning.TrafficRuleConfig.Parser, new[]{ "RuleId", "Enabled", "BacksideVehicle", "ChangeLane", "Crosswalk", "Destination", "KeepClear", "PullOver", "ReferenceLineEnd", "Rerouting", "SignalLight" }, new[]{ "Config" }, new[]{ typeof(global::Apollo.Planning.TrafficRuleConfig.Types.RuleId) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Apollo.Planning.TrafficRuleConfigs), global::Apollo.Planning.TrafficRuleConfigs.Parser, new[]{ "Config" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class BacksideVehicleConfig : pb::IMessage<BacksideVehicleConfig> {
    private static readonly pb::MessageParser<BacksideVehicleConfig> _parser = new pb::MessageParser<BacksideVehicleConfig>(() => new BacksideVehicleConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BacksideVehicleConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BacksideVehicleConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BacksideVehicleConfig(BacksideVehicleConfig other) : this() {
      backsideLaneWidth_ = other.backsideLaneWidth_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BacksideVehicleConfig Clone() {
      return new BacksideVehicleConfig(this);
    }

    /// <summary>Field number for the "backside_lane_width" field.</summary>
    public const int BacksideLaneWidthFieldNumber = 1;
    private double backsideLaneWidth_;
    /// <summary>
    /// a vehicle is considered within current lane if it is behind the ADC and its
    /// lateral difference is less than this number.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double BacksideLaneWidth {
      get { return backsideLaneWidth_; }
      set {
        backsideLaneWidth_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BacksideVehicleConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BacksideVehicleConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BacksideLaneWidth != other.BacksideLaneWidth) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BacksideLaneWidth != 0D) hash ^= BacksideLaneWidth.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (BacksideLaneWidth != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(BacksideLaneWidth);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BacksideLaneWidth != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BacksideVehicleConfig other) {
      if (other == null) {
        return;
      }
      if (other.BacksideLaneWidth != 0D) {
        BacksideLaneWidth = other.BacksideLaneWidth;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            BacksideLaneWidth = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ChangeLaneConfig : pb::IMessage<ChangeLaneConfig> {
    private static readonly pb::MessageParser<ChangeLaneConfig> _parser = new pb::MessageParser<ChangeLaneConfig>(() => new ChangeLaneConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ChangeLaneConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChangeLaneConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChangeLaneConfig(ChangeLaneConfig other) : this() {
      minOvertakeDistance_ = other.minOvertakeDistance_;
      minOvertakeTime_ = other.minOvertakeTime_;
      enableGuardObstacle_ = other.enableGuardObstacle_;
      guardDistance_ = other.guardDistance_;
      minGuardSpeed_ = other.minGuardSpeed_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChangeLaneConfig Clone() {
      return new ChangeLaneConfig(this);
    }

    /// <summary>Field number for the "min_overtake_distance" field.</summary>
    public const int MinOvertakeDistanceFieldNumber = 1;
    private double minOvertakeDistance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinOvertakeDistance {
      get { return minOvertakeDistance_; }
      set {
        minOvertakeDistance_ = value;
      }
    }

    /// <summary>Field number for the "min_overtake_time" field.</summary>
    public const int MinOvertakeTimeFieldNumber = 2;
    private double minOvertakeTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinOvertakeTime {
      get { return minOvertakeTime_; }
      set {
        minOvertakeTime_ = value;
      }
    }

    /// <summary>Field number for the "enable_guard_obstacle" field.</summary>
    public const int EnableGuardObstacleFieldNumber = 3;
    private bool enableGuardObstacle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableGuardObstacle {
      get { return enableGuardObstacle_; }
      set {
        enableGuardObstacle_ = value;
      }
    }

    /// <summary>Field number for the "guard_distance" field.</summary>
    public const int GuardDistanceFieldNumber = 4;
    private double guardDistance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double GuardDistance {
      get { return guardDistance_; }
      set {
        guardDistance_ = value;
      }
    }

    /// <summary>Field number for the "min_guard_speed" field.</summary>
    public const int MinGuardSpeedFieldNumber = 5;
    private double minGuardSpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinGuardSpeed {
      get { return minGuardSpeed_; }
      set {
        minGuardSpeed_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ChangeLaneConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ChangeLaneConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinOvertakeDistance != other.MinOvertakeDistance) return false;
      if (MinOvertakeTime != other.MinOvertakeTime) return false;
      if (EnableGuardObstacle != other.EnableGuardObstacle) return false;
      if (GuardDistance != other.GuardDistance) return false;
      if (MinGuardSpeed != other.MinGuardSpeed) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinOvertakeDistance != 0D) hash ^= MinOvertakeDistance.GetHashCode();
      if (MinOvertakeTime != 0D) hash ^= MinOvertakeTime.GetHashCode();
      if (EnableGuardObstacle != false) hash ^= EnableGuardObstacle.GetHashCode();
      if (GuardDistance != 0D) hash ^= GuardDistance.GetHashCode();
      if (MinGuardSpeed != 0D) hash ^= MinGuardSpeed.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinOvertakeDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(MinOvertakeDistance);
      }
      if (MinOvertakeTime != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(MinOvertakeTime);
      }
      if (EnableGuardObstacle != false) {
        output.WriteRawTag(24);
        output.WriteBool(EnableGuardObstacle);
      }
      if (GuardDistance != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(GuardDistance);
      }
      if (MinGuardSpeed != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(MinGuardSpeed);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinOvertakeDistance != 0D) {
        size += 1 + 8;
      }
      if (MinOvertakeTime != 0D) {
        size += 1 + 8;
      }
      if (EnableGuardObstacle != false) {
        size += 1 + 1;
      }
      if (GuardDistance != 0D) {
        size += 1 + 8;
      }
      if (MinGuardSpeed != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ChangeLaneConfig other) {
      if (other == null) {
        return;
      }
      if (other.MinOvertakeDistance != 0D) {
        MinOvertakeDistance = other.MinOvertakeDistance;
      }
      if (other.MinOvertakeTime != 0D) {
        MinOvertakeTime = other.MinOvertakeTime;
      }
      if (other.EnableGuardObstacle != false) {
        EnableGuardObstacle = other.EnableGuardObstacle;
      }
      if (other.GuardDistance != 0D) {
        GuardDistance = other.GuardDistance;
      }
      if (other.MinGuardSpeed != 0D) {
        MinGuardSpeed = other.MinGuardSpeed;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            MinOvertakeDistance = input.ReadDouble();
            break;
          }
          case 17: {
            MinOvertakeTime = input.ReadDouble();
            break;
          }
          case 24: {
            EnableGuardObstacle = input.ReadBool();
            break;
          }
          case 33: {
            GuardDistance = input.ReadDouble();
            break;
          }
          case 41: {
            MinGuardSpeed = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class CreepConfig : pb::IMessage<CreepConfig> {
    private static readonly pb::MessageParser<CreepConfig> _parser = new pb::MessageParser<CreepConfig>(() => new CreepConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreepConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreepConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreepConfig(CreepConfig other) : this() {
      enabled_ = other.enabled_;
      creepDistanceToStopLine_ = other.creepDistanceToStopLine_;
      stopDistance_ = other.stopDistance_;
      speedLimit_ = other.speedLimit_;
      maxValidStopDistance_ = other.maxValidStopDistance_;
      minBoundaryT_ = other.minBoundaryT_;
      minBoundaryS_ = other.minBoundaryS_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreepConfig Clone() {
      return new CreepConfig(this);
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 1;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "creep_distance_to_stop_line" field.</summary>
    public const int CreepDistanceToStopLineFieldNumber = 2;
    private double creepDistanceToStopLine_;
    /// <summary>
    /// stop distance(m) to the stop line of next lane overlap while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double CreepDistanceToStopLine {
      get { return creepDistanceToStopLine_; }
      set {
        creepDistanceToStopLine_ = value;
      }
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 3;
    private double stopDistance_;
    /// <summary>
    /// stop distance(m) to the stop line of next lane overlap while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "speed_limit" field.</summary>
    public const int SpeedLimitFieldNumber = 4;
    private double speedLimit_;
    /// <summary>
    /// m/s
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SpeedLimit {
      get { return speedLimit_; }
      set {
        speedLimit_ = value;
      }
    }

    /// <summary>Field number for the "max_valid_stop_distance" field.</summary>
    public const int MaxValidStopDistanceFieldNumber = 5;
    private double maxValidStopDistance_;
    /// <summary>
    /// max distance(m) to the stop line to be considered as a valid stop for creap
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxValidStopDistance {
      get { return maxValidStopDistance_; }
      set {
        maxValidStopDistance_ = value;
      }
    }

    /// <summary>Field number for the "min_boundary_t" field.</summary>
    public const int MinBoundaryTFieldNumber = 6;
    private double minBoundaryT_;
    /// <summary>
    /// min boundary t to ignore obstacles while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinBoundaryT {
      get { return minBoundaryT_; }
      set {
        minBoundaryT_ = value;
      }
    }

    /// <summary>Field number for the "min_boundary_s" field.</summary>
    public const int MinBoundarySFieldNumber = 7;
    private double minBoundaryS_;
    /// <summary>
    /// min boundary s to ignore obstacles while creeping
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinBoundaryS {
      get { return minBoundaryS_; }
      set {
        minBoundaryS_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreepConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreepConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enabled != other.Enabled) return false;
      if (CreepDistanceToStopLine != other.CreepDistanceToStopLine) return false;
      if (StopDistance != other.StopDistance) return false;
      if (SpeedLimit != other.SpeedLimit) return false;
      if (MaxValidStopDistance != other.MaxValidStopDistance) return false;
      if (MinBoundaryT != other.MinBoundaryT) return false;
      if (MinBoundaryS != other.MinBoundaryS) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (CreepDistanceToStopLine != 0D) hash ^= CreepDistanceToStopLine.GetHashCode();
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (SpeedLimit != 0D) hash ^= SpeedLimit.GetHashCode();
      if (MaxValidStopDistance != 0D) hash ^= MaxValidStopDistance.GetHashCode();
      if (MinBoundaryT != 0D) hash ^= MinBoundaryT.GetHashCode();
      if (MinBoundaryS != 0D) hash ^= MinBoundaryS.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enabled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enabled);
      }
      if (CreepDistanceToStopLine != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(CreepDistanceToStopLine);
      }
      if (StopDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(StopDistance);
      }
      if (SpeedLimit != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(SpeedLimit);
      }
      if (MaxValidStopDistance != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(MaxValidStopDistance);
      }
      if (MinBoundaryT != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(MinBoundaryT);
      }
      if (MinBoundaryS != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(MinBoundaryS);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (CreepDistanceToStopLine != 0D) {
        size += 1 + 8;
      }
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (SpeedLimit != 0D) {
        size += 1 + 8;
      }
      if (MaxValidStopDistance != 0D) {
        size += 1 + 8;
      }
      if (MinBoundaryT != 0D) {
        size += 1 + 8;
      }
      if (MinBoundaryS != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreepConfig other) {
      if (other == null) {
        return;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      if (other.CreepDistanceToStopLine != 0D) {
        CreepDistanceToStopLine = other.CreepDistanceToStopLine;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.SpeedLimit != 0D) {
        SpeedLimit = other.SpeedLimit;
      }
      if (other.MaxValidStopDistance != 0D) {
        MaxValidStopDistance = other.MaxValidStopDistance;
      }
      if (other.MinBoundaryT != 0D) {
        MinBoundaryT = other.MinBoundaryT;
      }
      if (other.MinBoundaryS != 0D) {
        MinBoundaryS = other.MinBoundaryS;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enabled = input.ReadBool();
            break;
          }
          case 17: {
            CreepDistanceToStopLine = input.ReadDouble();
            break;
          }
          case 25: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 33: {
            SpeedLimit = input.ReadDouble();
            break;
          }
          case 41: {
            MaxValidStopDistance = input.ReadDouble();
            break;
          }
          case 49: {
            MinBoundaryT = input.ReadDouble();
            break;
          }
          case 57: {
            MinBoundaryS = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class CrosswalkConfig : pb::IMessage<CrosswalkConfig> {
    private static readonly pb::MessageParser<CrosswalkConfig> _parser = new pb::MessageParser<CrosswalkConfig>(() => new CrosswalkConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CrosswalkConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrosswalkConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrosswalkConfig(CrosswalkConfig other) : this() {
      stopDistance_ = other.stopDistance_;
      maxStopDeceleration_ = other.maxStopDeceleration_;
      minPassSDistance_ = other.minPassSDistance_;
      maxStopSpeed_ = other.maxStopSpeed_;
      maxValidStopDistance_ = other.maxValidStopDistance_;
      expandSDistance_ = other.expandSDistance_;
      stopStrickLDistance_ = other.stopStrickLDistance_;
      stopLooseLDistance_ = other.stopLooseLDistance_;
      stopTimeout_ = other.stopTimeout_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrosswalkConfig Clone() {
      return new CrosswalkConfig(this);
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 1;
    private double stopDistance_;
    /// <summary>
    /// stop distance from stop line of crosswalk
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_stop_deceleration" field.</summary>
    public const int MaxStopDecelerationFieldNumber = 2;
    private double maxStopDeceleration_;
    /// <summary>
    /// max deceleration
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStopDeceleration {
      get { return maxStopDeceleration_; }
      set {
        maxStopDeceleration_ = value;
      }
    }

    /// <summary>Field number for the "min_pass_s_distance" field.</summary>
    public const int MinPassSDistanceFieldNumber = 3;
    private double minPassSDistance_;
    /// <summary>
    /// min s_distance for adc to be considered have passed crosswalk
    /// (stop_line_end_s)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinPassSDistance {
      get { return minPassSDistance_; }
      set {
        minPassSDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_stop_speed" field.</summary>
    public const int MaxStopSpeedFieldNumber = 4;
    private double maxStopSpeed_;
    /// <summary>
    /// max speed(m/s) to be considered as a valid stop
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStopSpeed {
      get { return maxStopSpeed_; }
      set {
        maxStopSpeed_ = value;
      }
    }

    /// <summary>Field number for the "max_valid_stop_distance" field.</summary>
    public const int MaxValidStopDistanceFieldNumber = 5;
    private double maxValidStopDistance_;
    /// <summary>
    /// max distance(m) to the stop line to be considered as a valid stop
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxValidStopDistance {
      get { return maxValidStopDistance_; }
      set {
        maxValidStopDistance_ = value;
      }
    }

    /// <summary>Field number for the "expand_s_distance" field.</summary>
    public const int ExpandSDistanceFieldNumber = 6;
    private double expandSDistance_;
    /// <summary>
    /// expand s_distance for pedestrian/bicycle detection
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ExpandSDistance {
      get { return expandSDistance_; }
      set {
        expandSDistance_ = value;
      }
    }

    /// <summary>Field number for the "stop_strick_l_distance" field.</summary>
    public const int StopStrickLDistanceFieldNumber = 7;
    private double stopStrickLDistance_;
    /// <summary>
    /// strick stop rule within this l_distance
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopStrickLDistance {
      get { return stopStrickLDistance_; }
      set {
        stopStrickLDistance_ = value;
      }
    }

    /// <summary>Field number for the "stop_loose_l_distance" field.</summary>
    public const int StopLooseLDistanceFieldNumber = 8;
    private double stopLooseLDistance_;
    /// <summary>
    /// loose stop rule beyond this l_distance
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopLooseLDistance {
      get { return stopLooseLDistance_; }
      set {
        stopLooseLDistance_ = value;
      }
    }

    /// <summary>Field number for the "stop_timeout" field.</summary>
    public const int StopTimeoutFieldNumber = 9;
    private double stopTimeout_;
    /// <summary>
    /// stop timeout for bicycles/pedestrians which are not moving
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopTimeout {
      get { return stopTimeout_; }
      set {
        stopTimeout_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CrosswalkConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CrosswalkConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StopDistance != other.StopDistance) return false;
      if (MaxStopDeceleration != other.MaxStopDeceleration) return false;
      if (MinPassSDistance != other.MinPassSDistance) return false;
      if (MaxStopSpeed != other.MaxStopSpeed) return false;
      if (MaxValidStopDistance != other.MaxValidStopDistance) return false;
      if (ExpandSDistance != other.ExpandSDistance) return false;
      if (StopStrickLDistance != other.StopStrickLDistance) return false;
      if (StopLooseLDistance != other.StopLooseLDistance) return false;
      if (StopTimeout != other.StopTimeout) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (MaxStopDeceleration != 0D) hash ^= MaxStopDeceleration.GetHashCode();
      if (MinPassSDistance != 0D) hash ^= MinPassSDistance.GetHashCode();
      if (MaxStopSpeed != 0D) hash ^= MaxStopSpeed.GetHashCode();
      if (MaxValidStopDistance != 0D) hash ^= MaxValidStopDistance.GetHashCode();
      if (ExpandSDistance != 0D) hash ^= ExpandSDistance.GetHashCode();
      if (StopStrickLDistance != 0D) hash ^= StopStrickLDistance.GetHashCode();
      if (StopLooseLDistance != 0D) hash ^= StopLooseLDistance.GetHashCode();
      if (StopTimeout != 0D) hash ^= StopTimeout.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StopDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(StopDistance);
      }
      if (MaxStopDeceleration != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(MaxStopDeceleration);
      }
      if (MinPassSDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(MinPassSDistance);
      }
      if (MaxStopSpeed != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(MaxStopSpeed);
      }
      if (MaxValidStopDistance != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(MaxValidStopDistance);
      }
      if (ExpandSDistance != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(ExpandSDistance);
      }
      if (StopStrickLDistance != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(StopStrickLDistance);
      }
      if (StopLooseLDistance != 0D) {
        output.WriteRawTag(65);
        output.WriteDouble(StopLooseLDistance);
      }
      if (StopTimeout != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(StopTimeout);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxStopDeceleration != 0D) {
        size += 1 + 8;
      }
      if (MinPassSDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxStopSpeed != 0D) {
        size += 1 + 8;
      }
      if (MaxValidStopDistance != 0D) {
        size += 1 + 8;
      }
      if (ExpandSDistance != 0D) {
        size += 1 + 8;
      }
      if (StopStrickLDistance != 0D) {
        size += 1 + 8;
      }
      if (StopLooseLDistance != 0D) {
        size += 1 + 8;
      }
      if (StopTimeout != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CrosswalkConfig other) {
      if (other == null) {
        return;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.MaxStopDeceleration != 0D) {
        MaxStopDeceleration = other.MaxStopDeceleration;
      }
      if (other.MinPassSDistance != 0D) {
        MinPassSDistance = other.MinPassSDistance;
      }
      if (other.MaxStopSpeed != 0D) {
        MaxStopSpeed = other.MaxStopSpeed;
      }
      if (other.MaxValidStopDistance != 0D) {
        MaxValidStopDistance = other.MaxValidStopDistance;
      }
      if (other.ExpandSDistance != 0D) {
        ExpandSDistance = other.ExpandSDistance;
      }
      if (other.StopStrickLDistance != 0D) {
        StopStrickLDistance = other.StopStrickLDistance;
      }
      if (other.StopLooseLDistance != 0D) {
        StopLooseLDistance = other.StopLooseLDistance;
      }
      if (other.StopTimeout != 0D) {
        StopTimeout = other.StopTimeout;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 17: {
            MaxStopDeceleration = input.ReadDouble();
            break;
          }
          case 25: {
            MinPassSDistance = input.ReadDouble();
            break;
          }
          case 33: {
            MaxStopSpeed = input.ReadDouble();
            break;
          }
          case 41: {
            MaxValidStopDistance = input.ReadDouble();
            break;
          }
          case 49: {
            ExpandSDistance = input.ReadDouble();
            break;
          }
          case 57: {
            StopStrickLDistance = input.ReadDouble();
            break;
          }
          case 65: {
            StopLooseLDistance = input.ReadDouble();
            break;
          }
          case 73: {
            StopTimeout = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class DestinationConfig : pb::IMessage<DestinationConfig> {
    private static readonly pb::MessageParser<DestinationConfig> _parser = new pb::MessageParser<DestinationConfig>(() => new DestinationConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DestinationConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DestinationConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DestinationConfig(DestinationConfig other) : this() {
      enablePullOver_ = other.enablePullOver_;
      stopDistance_ = other.stopDistance_;
      pullOverPlanDistance_ = other.pullOverPlanDistance_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DestinationConfig Clone() {
      return new DestinationConfig(this);
    }

    /// <summary>Field number for the "enable_pull_over" field.</summary>
    public const int EnablePullOverFieldNumber = 1;
    private bool enablePullOver_;
    /// <summary>
    /// flag to enable pullover upon arriving destination
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnablePullOver {
      get { return enablePullOver_; }
      set {
        enablePullOver_ = value;
      }
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 2;
    private double stopDistance_;
    /// <summary>
    /// stop distance from destination line
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "pull_over_plan_distance" field.</summary>
    public const int PullOverPlanDistanceFieldNumber = 3;
    private double pullOverPlanDistance_;
    /// <summary>
    /// distance to stop point to start planning pull over
    /// TODO(all): must be in sync with the same config in PULL_OVER will remove
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PullOverPlanDistance {
      get { return pullOverPlanDistance_; }
      set {
        pullOverPlanDistance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DestinationConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DestinationConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnablePullOver != other.EnablePullOver) return false;
      if (StopDistance != other.StopDistance) return false;
      if (PullOverPlanDistance != other.PullOverPlanDistance) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (EnablePullOver != false) hash ^= EnablePullOver.GetHashCode();
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (PullOverPlanDistance != 0D) hash ^= PullOverPlanDistance.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (EnablePullOver != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnablePullOver);
      }
      if (StopDistance != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(StopDistance);
      }
      if (PullOverPlanDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(PullOverPlanDistance);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (EnablePullOver != false) {
        size += 1 + 1;
      }
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (PullOverPlanDistance != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DestinationConfig other) {
      if (other == null) {
        return;
      }
      if (other.EnablePullOver != false) {
        EnablePullOver = other.EnablePullOver;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.PullOverPlanDistance != 0D) {
        PullOverPlanDistance = other.PullOverPlanDistance;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            EnablePullOver = input.ReadBool();
            break;
          }
          case 17: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 25: {
            PullOverPlanDistance = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class KeepClearConfig : pb::IMessage<KeepClearConfig> {
    private static readonly pb::MessageParser<KeepClearConfig> _parser = new pb::MessageParser<KeepClearConfig>(() => new KeepClearConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KeepClearConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeepClearConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeepClearConfig(KeepClearConfig other) : this() {
      enableKeepClearZone_ = other.enableKeepClearZone_;
      enableJunction_ = other.enableJunction_;
      minPassSDistance_ = other.minPassSDistance_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeepClearConfig Clone() {
      return new KeepClearConfig(this);
    }

    /// <summary>Field number for the "enable_keep_clear_zone" field.</summary>
    public const int EnableKeepClearZoneFieldNumber = 1;
    private bool enableKeepClearZone_;
    /// <summary>
    /// min s_distance to be considered have passed keep_clear (stop_line_end_s)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableKeepClearZone {
      get { return enableKeepClearZone_; }
      set {
        enableKeepClearZone_ = value;
      }
    }

    /// <summary>Field number for the "enable_junction" field.</summary>
    public const int EnableJunctionFieldNumber = 2;
    private bool enableJunction_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnableJunction {
      get { return enableJunction_; }
      set {
        enableJunction_ = value;
      }
    }

    /// <summary>Field number for the "min_pass_s_distance" field.</summary>
    public const int MinPassSDistanceFieldNumber = 3;
    private double minPassSDistance_;
    /// <summary>
    /// meter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinPassSDistance {
      get { return minPassSDistance_; }
      set {
        minPassSDistance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KeepClearConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KeepClearConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnableKeepClearZone != other.EnableKeepClearZone) return false;
      if (EnableJunction != other.EnableJunction) return false;
      if (MinPassSDistance != other.MinPassSDistance) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (EnableKeepClearZone != false) hash ^= EnableKeepClearZone.GetHashCode();
      if (EnableJunction != false) hash ^= EnableJunction.GetHashCode();
      if (MinPassSDistance != 0D) hash ^= MinPassSDistance.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (EnableKeepClearZone != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnableKeepClearZone);
      }
      if (EnableJunction != false) {
        output.WriteRawTag(16);
        output.WriteBool(EnableJunction);
      }
      if (MinPassSDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(MinPassSDistance);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (EnableKeepClearZone != false) {
        size += 1 + 1;
      }
      if (EnableJunction != false) {
        size += 1 + 1;
      }
      if (MinPassSDistance != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KeepClearConfig other) {
      if (other == null) {
        return;
      }
      if (other.EnableKeepClearZone != false) {
        EnableKeepClearZone = other.EnableKeepClearZone;
      }
      if (other.EnableJunction != false) {
        EnableJunction = other.EnableJunction;
      }
      if (other.MinPassSDistance != 0D) {
        MinPassSDistance = other.MinPassSDistance;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            EnableKeepClearZone = input.ReadBool();
            break;
          }
          case 16: {
            EnableJunction = input.ReadBool();
            break;
          }
          case 25: {
            MinPassSDistance = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class PullOverConfig : pb::IMessage<PullOverConfig> {
    private static readonly pb::MessageParser<PullOverConfig> _parser = new pb::MessageParser<PullOverConfig>(() => new PullOverConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PullOverConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PullOverConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PullOverConfig(PullOverConfig other) : this() {
      stopDistance_ = other.stopDistance_;
      maxStopSpeed_ = other.maxStopSpeed_;
      maxValidStopDistance_ = other.maxValidStopDistance_;
      maxStopDeceleration_ = other.maxStopDeceleration_;
      minPassSDistance_ = other.minPassSDistance_;
      bufferToBoundary_ = other.bufferToBoundary_;
      planDistance_ = other.planDistance_;
      operationLength_ = other.operationLength_;
      maxCheckDistance_ = other.maxCheckDistance_;
      maxFailureCount_ = other.maxFailureCount_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PullOverConfig Clone() {
      return new PullOverConfig(this);
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 1;
    private double stopDistance_;
    /// <summary>
    /// stop distance from stop line
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_stop_speed" field.</summary>
    public const int MaxStopSpeedFieldNumber = 2;
    private double maxStopSpeed_;
    /// <summary>
    /// max speed(m/s) to be considered as a valid stop
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStopSpeed {
      get { return maxStopSpeed_; }
      set {
        maxStopSpeed_ = value;
      }
    }

    /// <summary>Field number for the "max_valid_stop_distance" field.</summary>
    public const int MaxValidStopDistanceFieldNumber = 3;
    private double maxValidStopDistance_;
    /// <summary>
    /// max distance(m) to the stop line to be considered as a valid stop
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxValidStopDistance {
      get { return maxValidStopDistance_; }
      set {
        maxValidStopDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_stop_deceleration" field.</summary>
    public const int MaxStopDecelerationFieldNumber = 4;
    private double maxStopDeceleration_;
    /// <summary>
    /// max deceleration
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStopDeceleration {
      get { return maxStopDeceleration_; }
      set {
        maxStopDeceleration_ = value;
      }
    }

    /// <summary>Field number for the "min_pass_s_distance" field.</summary>
    public const int MinPassSDistanceFieldNumber = 5;
    private double minPassSDistance_;
    /// <summary>
    /// min s_distance for adc to be considered have passed crosswalk
    /// (stop_line_end_s)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinPassSDistance {
      get { return minPassSDistance_; }
      set {
        minPassSDistance_ = value;
      }
    }

    /// <summary>Field number for the "buffer_to_boundary" field.</summary>
    public const int BufferToBoundaryFieldNumber = 6;
    private double bufferToBoundary_;
    /// <summary>
    /// l-distance buffer to road/lane boundary
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double BufferToBoundary {
      get { return bufferToBoundary_; }
      set {
        bufferToBoundary_ = value;
      }
    }

    /// <summary>Field number for the "plan_distance" field.</summary>
    public const int PlanDistanceFieldNumber = 7;
    private double planDistance_;
    /// <summary>
    /// distance to stop point to start planning pull over
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PlanDistance {
      get { return planDistance_; }
      set {
        planDistance_ = value;
      }
    }

    /// <summary>Field number for the "operation_length" field.</summary>
    public const int OperationLengthFieldNumber = 8;
    private double operationLength_;
    /// <summary>
    /// s_distance to beteeen start and stop points
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double OperationLength {
      get { return operationLength_; }
      set {
        operationLength_ = value;
      }
    }

    /// <summary>Field number for the "max_check_distance" field.</summary>
    public const int MaxCheckDistanceFieldNumber = 9;
    private double maxCheckDistance_;
    /// <summary>
    /// max s_distance to check ahead while planning pull over
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxCheckDistance {
      get { return maxCheckDistance_; }
      set {
        maxCheckDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_failure_count" field.</summary>
    public const int MaxFailureCountFieldNumber = 10;
    private uint maxFailureCount_;
    /// <summary>
    /// max failure count before changing to stop in-lane
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MaxFailureCount {
      get { return maxFailureCount_; }
      set {
        maxFailureCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PullOverConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PullOverConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StopDistance != other.StopDistance) return false;
      if (MaxStopSpeed != other.MaxStopSpeed) return false;
      if (MaxValidStopDistance != other.MaxValidStopDistance) return false;
      if (MaxStopDeceleration != other.MaxStopDeceleration) return false;
      if (MinPassSDistance != other.MinPassSDistance) return false;
      if (BufferToBoundary != other.BufferToBoundary) return false;
      if (PlanDistance != other.PlanDistance) return false;
      if (OperationLength != other.OperationLength) return false;
      if (MaxCheckDistance != other.MaxCheckDistance) return false;
      if (MaxFailureCount != other.MaxFailureCount) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (MaxStopSpeed != 0D) hash ^= MaxStopSpeed.GetHashCode();
      if (MaxValidStopDistance != 0D) hash ^= MaxValidStopDistance.GetHashCode();
      if (MaxStopDeceleration != 0D) hash ^= MaxStopDeceleration.GetHashCode();
      if (MinPassSDistance != 0D) hash ^= MinPassSDistance.GetHashCode();
      if (BufferToBoundary != 0D) hash ^= BufferToBoundary.GetHashCode();
      if (PlanDistance != 0D) hash ^= PlanDistance.GetHashCode();
      if (OperationLength != 0D) hash ^= OperationLength.GetHashCode();
      if (MaxCheckDistance != 0D) hash ^= MaxCheckDistance.GetHashCode();
      if (MaxFailureCount != 0) hash ^= MaxFailureCount.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StopDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(StopDistance);
      }
      if (MaxStopSpeed != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(MaxStopSpeed);
      }
      if (MaxValidStopDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(MaxValidStopDistance);
      }
      if (MaxStopDeceleration != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(MaxStopDeceleration);
      }
      if (MinPassSDistance != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(MinPassSDistance);
      }
      if (BufferToBoundary != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(BufferToBoundary);
      }
      if (PlanDistance != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(PlanDistance);
      }
      if (OperationLength != 0D) {
        output.WriteRawTag(65);
        output.WriteDouble(OperationLength);
      }
      if (MaxCheckDistance != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(MaxCheckDistance);
      }
      if (MaxFailureCount != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(MaxFailureCount);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxStopSpeed != 0D) {
        size += 1 + 8;
      }
      if (MaxValidStopDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxStopDeceleration != 0D) {
        size += 1 + 8;
      }
      if (MinPassSDistance != 0D) {
        size += 1 + 8;
      }
      if (BufferToBoundary != 0D) {
        size += 1 + 8;
      }
      if (PlanDistance != 0D) {
        size += 1 + 8;
      }
      if (OperationLength != 0D) {
        size += 1 + 8;
      }
      if (MaxCheckDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxFailureCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxFailureCount);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PullOverConfig other) {
      if (other == null) {
        return;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.MaxStopSpeed != 0D) {
        MaxStopSpeed = other.MaxStopSpeed;
      }
      if (other.MaxValidStopDistance != 0D) {
        MaxValidStopDistance = other.MaxValidStopDistance;
      }
      if (other.MaxStopDeceleration != 0D) {
        MaxStopDeceleration = other.MaxStopDeceleration;
      }
      if (other.MinPassSDistance != 0D) {
        MinPassSDistance = other.MinPassSDistance;
      }
      if (other.BufferToBoundary != 0D) {
        BufferToBoundary = other.BufferToBoundary;
      }
      if (other.PlanDistance != 0D) {
        PlanDistance = other.PlanDistance;
      }
      if (other.OperationLength != 0D) {
        OperationLength = other.OperationLength;
      }
      if (other.MaxCheckDistance != 0D) {
        MaxCheckDistance = other.MaxCheckDistance;
      }
      if (other.MaxFailureCount != 0) {
        MaxFailureCount = other.MaxFailureCount;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 17: {
            MaxStopSpeed = input.ReadDouble();
            break;
          }
          case 25: {
            MaxValidStopDistance = input.ReadDouble();
            break;
          }
          case 33: {
            MaxStopDeceleration = input.ReadDouble();
            break;
          }
          case 41: {
            MinPassSDistance = input.ReadDouble();
            break;
          }
          case 49: {
            BufferToBoundary = input.ReadDouble();
            break;
          }
          case 57: {
            PlanDistance = input.ReadDouble();
            break;
          }
          case 65: {
            OperationLength = input.ReadDouble();
            break;
          }
          case 73: {
            MaxCheckDistance = input.ReadDouble();
            break;
          }
          case 80: {
            MaxFailureCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ReferenceLineEndConfig : pb::IMessage<ReferenceLineEndConfig> {
    private static readonly pb::MessageParser<ReferenceLineEndConfig> _parser = new pb::MessageParser<ReferenceLineEndConfig>(() => new ReferenceLineEndConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReferenceLineEndConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReferenceLineEndConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReferenceLineEndConfig(ReferenceLineEndConfig other) : this() {
      stopDistance_ = other.stopDistance_;
      minReferenceLineRemainLength_ = other.minReferenceLineRemainLength_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReferenceLineEndConfig Clone() {
      return new ReferenceLineEndConfig(this);
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 1;
    private double stopDistance_;
    /// <summary>
    /// stop distance from refrence line end
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "min_reference_line_remain_length" field.</summary>
    public const int MinReferenceLineRemainLengthFieldNumber = 2;
    private double minReferenceLineRemainLength_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinReferenceLineRemainLength {
      get { return minReferenceLineRemainLength_; }
      set {
        minReferenceLineRemainLength_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReferenceLineEndConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReferenceLineEndConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StopDistance != other.StopDistance) return false;
      if (MinReferenceLineRemainLength != other.MinReferenceLineRemainLength) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (MinReferenceLineRemainLength != 0D) hash ^= MinReferenceLineRemainLength.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StopDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(StopDistance);
      }
      if (MinReferenceLineRemainLength != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(MinReferenceLineRemainLength);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (MinReferenceLineRemainLength != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReferenceLineEndConfig other) {
      if (other == null) {
        return;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.MinReferenceLineRemainLength != 0D) {
        MinReferenceLineRemainLength = other.MinReferenceLineRemainLength;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 17: {
            MinReferenceLineRemainLength = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ReroutingConfig : pb::IMessage<ReroutingConfig> {
    private static readonly pb::MessageParser<ReroutingConfig> _parser = new pb::MessageParser<ReroutingConfig>(() => new ReroutingConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReroutingConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReroutingConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReroutingConfig(ReroutingConfig other) : this() {
      cooldownTime_ = other.cooldownTime_;
      prepareReroutingTime_ = other.prepareReroutingTime_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReroutingConfig Clone() {
      return new ReroutingConfig(this);
    }

    /// <summary>Field number for the "cooldown_time" field.</summary>
    public const int CooldownTimeFieldNumber = 1;
    private double cooldownTime_;
    /// <summary>
    /// should not rerouting more frequent than this number
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double CooldownTime {
      get { return cooldownTime_; }
      set {
        cooldownTime_ = value;
      }
    }

    /// <summary>Field number for the "prepare_rerouting_time" field.</summary>
    public const int PrepareReroutingTimeFieldNumber = 2;
    private double prepareReroutingTime_;
    /// <summary>
    /// seconds
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PrepareReroutingTime {
      get { return prepareReroutingTime_; }
      set {
        prepareReroutingTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReroutingConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReroutingConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CooldownTime != other.CooldownTime) return false;
      if (PrepareReroutingTime != other.PrepareReroutingTime) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CooldownTime != 0D) hash ^= CooldownTime.GetHashCode();
      if (PrepareReroutingTime != 0D) hash ^= PrepareReroutingTime.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CooldownTime != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(CooldownTime);
      }
      if (PrepareReroutingTime != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(PrepareReroutingTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CooldownTime != 0D) {
        size += 1 + 8;
      }
      if (PrepareReroutingTime != 0D) {
        size += 1 + 8;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReroutingConfig other) {
      if (other == null) {
        return;
      }
      if (other.CooldownTime != 0D) {
        CooldownTime = other.CooldownTime;
      }
      if (other.PrepareReroutingTime != 0D) {
        PrepareReroutingTime = other.PrepareReroutingTime;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            CooldownTime = input.ReadDouble();
            break;
          }
          case 17: {
            PrepareReroutingTime = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SignalLightConfig : pb::IMessage<SignalLightConfig> {
    private static readonly pb::MessageParser<SignalLightConfig> _parser = new pb::MessageParser<SignalLightConfig>(() => new SignalLightConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignalLightConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignalLightConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignalLightConfig(SignalLightConfig other) : this() {
      stopDistance_ = other.stopDistance_;
      maxStopDeceleration_ = other.maxStopDeceleration_;
      minPassSDistance_ = other.minPassSDistance_;
      maxStopDeaccelerationYellowLight_ = other.maxStopDeaccelerationYellowLight_;
      signalExpireTimeSec_ = other.signalExpireTimeSec_;
      maxMonitorForwardDistance_ = other.maxMonitorForwardDistance_;
      RighTurnCreep = other.righTurnCreep_ != null ? other.RighTurnCreep.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignalLightConfig Clone() {
      return new SignalLightConfig(this);
    }

    /// <summary>Field number for the "stop_distance" field.</summary>
    public const int StopDistanceFieldNumber = 1;
    private double stopDistance_;
    /// <summary>
    /// stop distance from stop line
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StopDistance {
      get { return stopDistance_; }
      set {
        stopDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_stop_deceleration" field.</summary>
    public const int MaxStopDecelerationFieldNumber = 2;
    private double maxStopDeceleration_;
    /// <summary>
    /// max deceleration
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStopDeceleration {
      get { return maxStopDeceleration_; }
      set {
        maxStopDeceleration_ = value;
      }
    }

    /// <summary>Field number for the "min_pass_s_distance" field.</summary>
    public const int MinPassSDistanceFieldNumber = 3;
    private double minPassSDistance_;
    /// <summary>
    /// min s_distance for adc to be considered have passed signal_light
    /// (stop_line_end_s)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinPassSDistance {
      get { return minPassSDistance_; }
      set {
        minPassSDistance_ = value;
      }
    }

    /// <summary>Field number for the "max_stop_deacceleration_yellow_light" field.</summary>
    public const int MaxStopDeaccelerationYellowLightFieldNumber = 4;
    private double maxStopDeaccelerationYellowLight_;
    /// <summary>
    /// treat yellow light as red when deceleration (abstract value in m/s^2)
    /// is less than this threshold; otherwise treated as green light
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxStopDeaccelerationYellowLight {
      get { return maxStopDeaccelerationYellowLight_; }
      set {
        maxStopDeaccelerationYellowLight_ = value;
      }
    }

    /// <summary>Field number for the "signal_expire_time_sec" field.</summary>
    public const int SignalExpireTimeSecFieldNumber = 5;
    private double signalExpireTimeSec_;
    /// <summary>
    /// second
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SignalExpireTimeSec {
      get { return signalExpireTimeSec_; }
      set {
        signalExpireTimeSec_ = value;
      }
    }

    /// <summary>Field number for the "max_monitor_forward_distance" field.</summary>
    public const int MaxMonitorForwardDistanceFieldNumber = 6;
    private double maxMonitorForwardDistance_;
    /// <summary>
    /// meter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaxMonitorForwardDistance {
      get { return maxMonitorForwardDistance_; }
      set {
        maxMonitorForwardDistance_ = value;
      }
    }

    /// <summary>Field number for the "righ_turn_creep" field.</summary>
    public const int RighTurnCreepFieldNumber = 7;
    private global::Apollo.Planning.CreepConfig righTurnCreep_;
    /// <summary>
    /// consider the signal msg is expired if its timestamp over this threshold(s)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.CreepConfig RighTurnCreep {
      get { return righTurnCreep_; }
      set {
        righTurnCreep_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignalLightConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignalLightConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StopDistance != other.StopDistance) return false;
      if (MaxStopDeceleration != other.MaxStopDeceleration) return false;
      if (MinPassSDistance != other.MinPassSDistance) return false;
      if (MaxStopDeaccelerationYellowLight != other.MaxStopDeaccelerationYellowLight) return false;
      if (SignalExpireTimeSec != other.SignalExpireTimeSec) return false;
      if (MaxMonitorForwardDistance != other.MaxMonitorForwardDistance) return false;
      if (!object.Equals(RighTurnCreep, other.RighTurnCreep)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StopDistance != 0D) hash ^= StopDistance.GetHashCode();
      if (MaxStopDeceleration != 0D) hash ^= MaxStopDeceleration.GetHashCode();
      if (MinPassSDistance != 0D) hash ^= MinPassSDistance.GetHashCode();
      if (MaxStopDeaccelerationYellowLight != 0D) hash ^= MaxStopDeaccelerationYellowLight.GetHashCode();
      if (SignalExpireTimeSec != 0D) hash ^= SignalExpireTimeSec.GetHashCode();
      if (MaxMonitorForwardDistance != 0D) hash ^= MaxMonitorForwardDistance.GetHashCode();
      if (righTurnCreep_ != null) hash ^= RighTurnCreep.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StopDistance != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(StopDistance);
      }
      if (MaxStopDeceleration != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(MaxStopDeceleration);
      }
      if (MinPassSDistance != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(MinPassSDistance);
      }
      if (MaxStopDeaccelerationYellowLight != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(MaxStopDeaccelerationYellowLight);
      }
      if (SignalExpireTimeSec != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(SignalExpireTimeSec);
      }
      if (MaxMonitorForwardDistance != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(MaxMonitorForwardDistance);
      }
      if (righTurnCreep_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(RighTurnCreep);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StopDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxStopDeceleration != 0D) {
        size += 1 + 8;
      }
      if (MinPassSDistance != 0D) {
        size += 1 + 8;
      }
      if (MaxStopDeaccelerationYellowLight != 0D) {
        size += 1 + 8;
      }
      if (SignalExpireTimeSec != 0D) {
        size += 1 + 8;
      }
      if (MaxMonitorForwardDistance != 0D) {
        size += 1 + 8;
      }
      if (righTurnCreep_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RighTurnCreep);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignalLightConfig other) {
      if (other == null) {
        return;
      }
      if (other.StopDistance != 0D) {
        StopDistance = other.StopDistance;
      }
      if (other.MaxStopDeceleration != 0D) {
        MaxStopDeceleration = other.MaxStopDeceleration;
      }
      if (other.MinPassSDistance != 0D) {
        MinPassSDistance = other.MinPassSDistance;
      }
      if (other.MaxStopDeaccelerationYellowLight != 0D) {
        MaxStopDeaccelerationYellowLight = other.MaxStopDeaccelerationYellowLight;
      }
      if (other.SignalExpireTimeSec != 0D) {
        SignalExpireTimeSec = other.SignalExpireTimeSec;
      }
      if (other.MaxMonitorForwardDistance != 0D) {
        MaxMonitorForwardDistance = other.MaxMonitorForwardDistance;
      }
      if (other.righTurnCreep_ != null) {
        if (righTurnCreep_ == null) {
          righTurnCreep_ = new global::Apollo.Planning.CreepConfig();
        }
        RighTurnCreep.MergeFrom(other.RighTurnCreep);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            StopDistance = input.ReadDouble();
            break;
          }
          case 17: {
            MaxStopDeceleration = input.ReadDouble();
            break;
          }
          case 25: {
            MinPassSDistance = input.ReadDouble();
            break;
          }
          case 33: {
            MaxStopDeaccelerationYellowLight = input.ReadDouble();
            break;
          }
          case 41: {
            SignalExpireTimeSec = input.ReadDouble();
            break;
          }
          case 49: {
            MaxMonitorForwardDistance = input.ReadDouble();
            break;
          }
          case 58: {
            if (righTurnCreep_ == null) {
              righTurnCreep_ = new global::Apollo.Planning.CreepConfig();
            }
            input.ReadMessage(righTurnCreep_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// TODO(all) migrate all other traffic rules to pb config
  /// </summary>
  public sealed partial class TrafficRuleConfig : pb::IMessage<TrafficRuleConfig> {
    private static readonly pb::MessageParser<TrafficRuleConfig> _parser = new pb::MessageParser<TrafficRuleConfig>(() => new TrafficRuleConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TrafficRuleConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficRuleConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficRuleConfig(TrafficRuleConfig other) : this() {
      ruleId_ = other.ruleId_;
      enabled_ = other.enabled_;
      switch (other.ConfigCase) {
        case ConfigOneofCase.BacksideVehicle:
          BacksideVehicle = other.BacksideVehicle.Clone();
          break;
        case ConfigOneofCase.ChangeLane:
          ChangeLane = other.ChangeLane.Clone();
          break;
        case ConfigOneofCase.Crosswalk:
          Crosswalk = other.Crosswalk.Clone();
          break;
        case ConfigOneofCase.Destination:
          Destination = other.Destination.Clone();
          break;
        case ConfigOneofCase.KeepClear:
          KeepClear = other.KeepClear.Clone();
          break;
        case ConfigOneofCase.PullOver:
          PullOver = other.PullOver.Clone();
          break;
        case ConfigOneofCase.ReferenceLineEnd:
          ReferenceLineEnd = other.ReferenceLineEnd.Clone();
          break;
        case ConfigOneofCase.Rerouting:
          Rerouting = other.Rerouting.Clone();
          break;
        case ConfigOneofCase.SignalLight:
          SignalLight = other.SignalLight.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficRuleConfig Clone() {
      return new TrafficRuleConfig(this);
    }

    /// <summary>Field number for the "rule_id" field.</summary>
    public const int RuleIdFieldNumber = 1;
    private global::Apollo.Planning.TrafficRuleConfig.Types.RuleId ruleId_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.TrafficRuleConfig.Types.RuleId RuleId {
      get { return ruleId_; }
      set {
        ruleId_ = value;
      }
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 2;
    private bool enabled_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    /// <summary>Field number for the "backside_vehicle" field.</summary>
    public const int BacksideVehicleFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.BacksideVehicleConfig BacksideVehicle {
      get { return configCase_ == ConfigOneofCase.BacksideVehicle ? (global::Apollo.Planning.BacksideVehicleConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.BacksideVehicle;
      }
    }

    /// <summary>Field number for the "change_lane" field.</summary>
    public const int ChangeLaneFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.ChangeLaneConfig ChangeLane {
      get { return configCase_ == ConfigOneofCase.ChangeLane ? (global::Apollo.Planning.ChangeLaneConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.ChangeLane;
      }
    }

    /// <summary>Field number for the "crosswalk" field.</summary>
    public const int CrosswalkFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.CrosswalkConfig Crosswalk {
      get { return configCase_ == ConfigOneofCase.Crosswalk ? (global::Apollo.Planning.CrosswalkConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.Crosswalk;
      }
    }

    /// <summary>Field number for the "destination" field.</summary>
    public const int DestinationFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.DestinationConfig Destination {
      get { return configCase_ == ConfigOneofCase.Destination ? (global::Apollo.Planning.DestinationConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.Destination;
      }
    }

    /// <summary>Field number for the "keep_clear" field.</summary>
    public const int KeepClearFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.KeepClearConfig KeepClear {
      get { return configCase_ == ConfigOneofCase.KeepClear ? (global::Apollo.Planning.KeepClearConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.KeepClear;
      }
    }

    /// <summary>Field number for the "pull_over" field.</summary>
    public const int PullOverFieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.PullOverConfig PullOver {
      get { return configCase_ == ConfigOneofCase.PullOver ? (global::Apollo.Planning.PullOverConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.PullOver;
      }
    }

    /// <summary>Field number for the "reference_line_end" field.</summary>
    public const int ReferenceLineEndFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.ReferenceLineEndConfig ReferenceLineEnd {
      get { return configCase_ == ConfigOneofCase.ReferenceLineEnd ? (global::Apollo.Planning.ReferenceLineEndConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.ReferenceLineEnd;
      }
    }

    /// <summary>Field number for the "rerouting" field.</summary>
    public const int ReroutingFieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.ReroutingConfig Rerouting {
      get { return configCase_ == ConfigOneofCase.Rerouting ? (global::Apollo.Planning.ReroutingConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.Rerouting;
      }
    }

    /// <summary>Field number for the "signal_light" field.</summary>
    public const int SignalLightFieldNumber = 11;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Apollo.Planning.SignalLightConfig SignalLight {
      get { return configCase_ == ConfigOneofCase.SignalLight ? (global::Apollo.Planning.SignalLightConfig) config_ : null; }
      set {
        config_ = value;
        configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.SignalLight;
      }
    }

    private object config_;
    /// <summary>Enum of possible cases for the "config" oneof.</summary>
    public enum ConfigOneofCase {
      None = 0,
      BacksideVehicle = 3,
      ChangeLane = 4,
      Crosswalk = 5,
      Destination = 6,
      KeepClear = 7,
      PullOver = 8,
      ReferenceLineEnd = 9,
      Rerouting = 10,
      SignalLight = 11,
    }
    private ConfigOneofCase configCase_ = ConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigOneofCase ConfigCase {
      get { return configCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfig() {
      configCase_ = ConfigOneofCase.None;
      config_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TrafficRuleConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TrafficRuleConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RuleId != other.RuleId) return false;
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(BacksideVehicle, other.BacksideVehicle)) return false;
      if (!object.Equals(ChangeLane, other.ChangeLane)) return false;
      if (!object.Equals(Crosswalk, other.Crosswalk)) return false;
      if (!object.Equals(Destination, other.Destination)) return false;
      if (!object.Equals(KeepClear, other.KeepClear)) return false;
      if (!object.Equals(PullOver, other.PullOver)) return false;
      if (!object.Equals(ReferenceLineEnd, other.ReferenceLineEnd)) return false;
      if (!object.Equals(Rerouting, other.Rerouting)) return false;
      if (!object.Equals(SignalLight, other.SignalLight)) return false;
      if (ConfigCase != other.ConfigCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RuleId != 0) hash ^= RuleId.GetHashCode();
      if (Enabled != false) hash ^= Enabled.GetHashCode();
      if (configCase_ == ConfigOneofCase.BacksideVehicle) hash ^= BacksideVehicle.GetHashCode();
      if (configCase_ == ConfigOneofCase.ChangeLane) hash ^= ChangeLane.GetHashCode();
      if (configCase_ == ConfigOneofCase.Crosswalk) hash ^= Crosswalk.GetHashCode();
      if (configCase_ == ConfigOneofCase.Destination) hash ^= Destination.GetHashCode();
      if (configCase_ == ConfigOneofCase.KeepClear) hash ^= KeepClear.GetHashCode();
      if (configCase_ == ConfigOneofCase.PullOver) hash ^= PullOver.GetHashCode();
      if (configCase_ == ConfigOneofCase.ReferenceLineEnd) hash ^= ReferenceLineEnd.GetHashCode();
      if (configCase_ == ConfigOneofCase.Rerouting) hash ^= Rerouting.GetHashCode();
      if (configCase_ == ConfigOneofCase.SignalLight) hash ^= SignalLight.GetHashCode();
      hash ^= (int) configCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (RuleId != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RuleId);
      }
      if (Enabled != false) {
        output.WriteRawTag(16);
        output.WriteBool(Enabled);
      }
      if (configCase_ == ConfigOneofCase.BacksideVehicle) {
        output.WriteRawTag(26);
        output.WriteMessage(BacksideVehicle);
      }
      if (configCase_ == ConfigOneofCase.ChangeLane) {
        output.WriteRawTag(34);
        output.WriteMessage(ChangeLane);
      }
      if (configCase_ == ConfigOneofCase.Crosswalk) {
        output.WriteRawTag(42);
        output.WriteMessage(Crosswalk);
      }
      if (configCase_ == ConfigOneofCase.Destination) {
        output.WriteRawTag(50);
        output.WriteMessage(Destination);
      }
      if (configCase_ == ConfigOneofCase.KeepClear) {
        output.WriteRawTag(58);
        output.WriteMessage(KeepClear);
      }
      if (configCase_ == ConfigOneofCase.PullOver) {
        output.WriteRawTag(66);
        output.WriteMessage(PullOver);
      }
      if (configCase_ == ConfigOneofCase.ReferenceLineEnd) {
        output.WriteRawTag(74);
        output.WriteMessage(ReferenceLineEnd);
      }
      if (configCase_ == ConfigOneofCase.Rerouting) {
        output.WriteRawTag(82);
        output.WriteMessage(Rerouting);
      }
      if (configCase_ == ConfigOneofCase.SignalLight) {
        output.WriteRawTag(90);
        output.WriteMessage(SignalLight);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RuleId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RuleId);
      }
      if (Enabled != false) {
        size += 1 + 1;
      }
      if (configCase_ == ConfigOneofCase.BacksideVehicle) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BacksideVehicle);
      }
      if (configCase_ == ConfigOneofCase.ChangeLane) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ChangeLane);
      }
      if (configCase_ == ConfigOneofCase.Crosswalk) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Crosswalk);
      }
      if (configCase_ == ConfigOneofCase.Destination) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Destination);
      }
      if (configCase_ == ConfigOneofCase.KeepClear) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeepClear);
      }
      if (configCase_ == ConfigOneofCase.PullOver) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PullOver);
      }
      if (configCase_ == ConfigOneofCase.ReferenceLineEnd) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceLineEnd);
      }
      if (configCase_ == ConfigOneofCase.Rerouting) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rerouting);
      }
      if (configCase_ == ConfigOneofCase.SignalLight) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SignalLight);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TrafficRuleConfig other) {
      if (other == null) {
        return;
      }
      if (other.RuleId != 0) {
        RuleId = other.RuleId;
      }
      if (other.Enabled != false) {
        Enabled = other.Enabled;
      }
      switch (other.ConfigCase) {
        case ConfigOneofCase.BacksideVehicle:
          BacksideVehicle = other.BacksideVehicle;
          break;
        case ConfigOneofCase.ChangeLane:
          ChangeLane = other.ChangeLane;
          break;
        case ConfigOneofCase.Crosswalk:
          Crosswalk = other.Crosswalk;
          break;
        case ConfigOneofCase.Destination:
          Destination = other.Destination;
          break;
        case ConfigOneofCase.KeepClear:
          KeepClear = other.KeepClear;
          break;
        case ConfigOneofCase.PullOver:
          PullOver = other.PullOver;
          break;
        case ConfigOneofCase.ReferenceLineEnd:
          ReferenceLineEnd = other.ReferenceLineEnd;
          break;
        case ConfigOneofCase.Rerouting:
          Rerouting = other.Rerouting;
          break;
        case ConfigOneofCase.SignalLight:
          SignalLight = other.SignalLight;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            ruleId_ = (global::Apollo.Planning.TrafficRuleConfig.Types.RuleId) input.ReadEnum();
            break;
          }
          case 16: {
            Enabled = input.ReadBool();
            break;
          }
          case 26: {
            global::Apollo.Planning.BacksideVehicleConfig subBuilder = new global::Apollo.Planning.BacksideVehicleConfig();
            if (configCase_ == ConfigOneofCase.BacksideVehicle) {
              subBuilder.MergeFrom(BacksideVehicle);
            }
            input.ReadMessage(subBuilder);
            BacksideVehicle = subBuilder;
            break;
          }
          case 34: {
            global::Apollo.Planning.ChangeLaneConfig subBuilder = new global::Apollo.Planning.ChangeLaneConfig();
            if (configCase_ == ConfigOneofCase.ChangeLane) {
              subBuilder.MergeFrom(ChangeLane);
            }
            input.ReadMessage(subBuilder);
            ChangeLane = subBuilder;
            break;
          }
          case 42: {
            global::Apollo.Planning.CrosswalkConfig subBuilder = new global::Apollo.Planning.CrosswalkConfig();
            if (configCase_ == ConfigOneofCase.Crosswalk) {
              subBuilder.MergeFrom(Crosswalk);
            }
            input.ReadMessage(subBuilder);
            Crosswalk = subBuilder;
            break;
          }
          case 50: {
            global::Apollo.Planning.DestinationConfig subBuilder = new global::Apollo.Planning.DestinationConfig();
            if (configCase_ == ConfigOneofCase.Destination) {
              subBuilder.MergeFrom(Destination);
            }
            input.ReadMessage(subBuilder);
            Destination = subBuilder;
            break;
          }
          case 58: {
            global::Apollo.Planning.KeepClearConfig subBuilder = new global::Apollo.Planning.KeepClearConfig();
            if (configCase_ == ConfigOneofCase.KeepClear) {
              subBuilder.MergeFrom(KeepClear);
            }
            input.ReadMessage(subBuilder);
            KeepClear = subBuilder;
            break;
          }
          case 66: {
            global::Apollo.Planning.PullOverConfig subBuilder = new global::Apollo.Planning.PullOverConfig();
            if (configCase_ == ConfigOneofCase.PullOver) {
              subBuilder.MergeFrom(PullOver);
            }
            input.ReadMessage(subBuilder);
            PullOver = subBuilder;
            break;
          }
          case 74: {
            global::Apollo.Planning.ReferenceLineEndConfig subBuilder = new global::Apollo.Planning.ReferenceLineEndConfig();
            if (configCase_ == ConfigOneofCase.ReferenceLineEnd) {
              subBuilder.MergeFrom(ReferenceLineEnd);
            }
            input.ReadMessage(subBuilder);
            ReferenceLineEnd = subBuilder;
            break;
          }
          case 82: {
            global::Apollo.Planning.ReroutingConfig subBuilder = new global::Apollo.Planning.ReroutingConfig();
            if (configCase_ == ConfigOneofCase.Rerouting) {
              subBuilder.MergeFrom(Rerouting);
            }
            input.ReadMessage(subBuilder);
            Rerouting = subBuilder;
            break;
          }
          case 90: {
            global::Apollo.Planning.SignalLightConfig subBuilder = new global::Apollo.Planning.SignalLightConfig();
            if (configCase_ == ConfigOneofCase.SignalLight) {
              subBuilder.MergeFrom(SignalLight);
            }
            input.ReadMessage(subBuilder);
            SignalLight = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TrafficRuleConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum RuleId {
        [pbr::OriginalName("RULEID_DUMMY")] Dummy = 0,
        [pbr::OriginalName("BACKSIDE_VEHICLE")] BacksideVehicle = 1,
        [pbr::OriginalName("CHANGE_LANE")] ChangeLane = 2,
        [pbr::OriginalName("CROSSWALK")] Crosswalk = 3,
        [pbr::OriginalName("DESTINATION")] Destination = 4,
        [pbr::OriginalName("KEEP_CLEAR")] KeepClear = 5,
        [pbr::OriginalName("PULL_OVER")] PullOver = 6,
        [pbr::OriginalName("REFERENCE_LINE_END")] ReferenceLineEnd = 7,
        [pbr::OriginalName("REROUTING")] Rerouting = 8,
        [pbr::OriginalName("SIGNAL_LIGHT")] SignalLight = 9,
        [pbr::OriginalName("STOP_SIGN")] StopSign = 10,
      }

    }
    #endregion

  }

  public sealed partial class TrafficRuleConfigs : pb::IMessage<TrafficRuleConfigs> {
    private static readonly pb::MessageParser<TrafficRuleConfigs> _parser = new pb::MessageParser<TrafficRuleConfigs>(() => new TrafficRuleConfigs());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TrafficRuleConfigs> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Apollo.Planning.TrafficRuleConfigReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficRuleConfigs() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficRuleConfigs(TrafficRuleConfigs other) : this() {
      config_ = other.config_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficRuleConfigs Clone() {
      return new TrafficRuleConfigs(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Apollo.Planning.TrafficRuleConfig> _repeated_config_codec
        = pb::FieldCodec.ForMessage(10, global::Apollo.Planning.TrafficRuleConfig.Parser);
    private readonly pbc::RepeatedField<global::Apollo.Planning.TrafficRuleConfig> config_ = new pbc::RepeatedField<global::Apollo.Planning.TrafficRuleConfig>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Apollo.Planning.TrafficRuleConfig> Config {
      get { return config_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TrafficRuleConfigs);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TrafficRuleConfigs other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!config_.Equals(other.config_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= config_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      config_.WriteTo(output, _repeated_config_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += config_.CalculateSize(_repeated_config_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TrafficRuleConfigs other) {
      if (other == null) {
        return;
      }
      config_.Add(other.config_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            config_.AddEntriesFrom(input, _repeated_config_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
